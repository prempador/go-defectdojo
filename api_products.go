/*
Defect Dojo API v2

Defect Dojo - Open Source vulnerability Management made easy. Prefetch related parameters/responses not yet in the schema.

API version: 2.31.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package defectdojo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


type ProductsAPI interface {

	/*
	ProductsCreate Method for ProductsCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiProductsCreateRequest
	*/
	ProductsCreate(ctx context.Context) ApiProductsCreateRequest

	// ProductsCreateExecute executes the request
	//  @return Product
	ProductsCreateExecute(r ApiProductsCreateRequest) (*Product, *http.Response, error)

	/*
	ProductsDeletePreviewList Method for ProductsDeletePreviewList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this product.
	@return ApiProductsDeletePreviewListRequest
	*/
	ProductsDeletePreviewList(ctx context.Context, id int32) ApiProductsDeletePreviewListRequest

	// ProductsDeletePreviewListExecute executes the request
	//  @return PaginatedDeletePreviewList
	ProductsDeletePreviewListExecute(r ApiProductsDeletePreviewListRequest) (*PaginatedDeletePreviewList, *http.Response, error)

	/*
	ProductsDestroy Method for ProductsDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this product.
	@return ApiProductsDestroyRequest
	*/
	ProductsDestroy(ctx context.Context, id int32) ApiProductsDestroyRequest

	// ProductsDestroyExecute executes the request
	ProductsDestroyExecute(r ApiProductsDestroyRequest) (*http.Response, error)

	/*
	ProductsGenerateReportCreate Method for ProductsGenerateReportCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this product.
	@return ApiProductsGenerateReportCreateRequest
	*/
	ProductsGenerateReportCreate(ctx context.Context, id int32) ApiProductsGenerateReportCreateRequest

	// ProductsGenerateReportCreateExecute executes the request
	//  @return ReportGenerate
	ProductsGenerateReportCreateExecute(r ApiProductsGenerateReportCreateRequest) (*ReportGenerate, *http.Response, error)

	/*
	ProductsList Method for ProductsList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiProductsListRequest
	*/
	ProductsList(ctx context.Context) ApiProductsListRequest

	// ProductsListExecute executes the request
	//  @return PaginatedProductList
	ProductsListExecute(r ApiProductsListRequest) (*PaginatedProductList, *http.Response, error)

	/*
	ProductsPartialUpdate Method for ProductsPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this product.
	@return ApiProductsPartialUpdateRequest
	*/
	ProductsPartialUpdate(ctx context.Context, id int32) ApiProductsPartialUpdateRequest

	// ProductsPartialUpdateExecute executes the request
	//  @return Product
	ProductsPartialUpdateExecute(r ApiProductsPartialUpdateRequest) (*Product, *http.Response, error)

	/*
	ProductsRetrieve Method for ProductsRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this product.
	@return ApiProductsRetrieveRequest
	*/
	ProductsRetrieve(ctx context.Context, id int32) ApiProductsRetrieveRequest

	// ProductsRetrieveExecute executes the request
	//  @return Product
	ProductsRetrieveExecute(r ApiProductsRetrieveRequest) (*Product, *http.Response, error)

	/*
	ProductsUpdate Method for ProductsUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this product.
	@return ApiProductsUpdateRequest
	*/
	ProductsUpdate(ctx context.Context, id int32) ApiProductsUpdateRequest

	// ProductsUpdateExecute executes the request
	//  @return Product
	ProductsUpdateExecute(r ApiProductsUpdateRequest) (*Product, *http.Response, error)
}

// ProductsAPIService ProductsAPI service
type ProductsAPIService service

type ApiProductsCreateRequest struct {
	ctx context.Context
	ApiService ProductsAPI
	productRequest *ProductRequest
}

func (r ApiProductsCreateRequest) ProductRequest(productRequest ProductRequest) ApiProductsCreateRequest {
	r.productRequest = &productRequest
	return r
}

func (r ApiProductsCreateRequest) Execute() (*Product, *http.Response, error) {
	return r.ApiService.ProductsCreateExecute(r)
}

/*
ProductsCreate Method for ProductsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductsCreateRequest
*/
func (a *ProductsAPIService) ProductsCreate(ctx context.Context) ApiProductsCreateRequest {
	return ApiProductsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Product
func (a *ProductsAPIService) ProductsCreateExecute(r ApiProductsCreateRequest) (*Product, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Product
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsAPIService.ProductsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/products/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productRequest == nil {
		return localVarReturnValue, nil, reportError("productRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductsDeletePreviewListRequest struct {
	ctx context.Context
	ApiService ProductsAPI
	id int32
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiProductsDeletePreviewListRequest) Limit(limit int32) ApiProductsDeletePreviewListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiProductsDeletePreviewListRequest) Offset(offset int32) ApiProductsDeletePreviewListRequest {
	r.offset = &offset
	return r
}

func (r ApiProductsDeletePreviewListRequest) Execute() (*PaginatedDeletePreviewList, *http.Response, error) {
	return r.ApiService.ProductsDeletePreviewListExecute(r)
}

/*
ProductsDeletePreviewList Method for ProductsDeletePreviewList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this product.
 @return ApiProductsDeletePreviewListRequest
*/
func (a *ProductsAPIService) ProductsDeletePreviewList(ctx context.Context, id int32) ApiProductsDeletePreviewListRequest {
	return ApiProductsDeletePreviewListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedDeletePreviewList
func (a *ProductsAPIService) ProductsDeletePreviewListExecute(r ApiProductsDeletePreviewListRequest) (*PaginatedDeletePreviewList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeletePreviewList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsAPIService.ProductsDeletePreviewList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/products/{id}/delete_preview/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductsDestroyRequest struct {
	ctx context.Context
	ApiService ProductsAPI
	id int32
}

func (r ApiProductsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProductsDestroyExecute(r)
}

/*
ProductsDestroy Method for ProductsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this product.
 @return ApiProductsDestroyRequest
*/
func (a *ProductsAPIService) ProductsDestroy(ctx context.Context, id int32) ApiProductsDestroyRequest {
	return ApiProductsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProductsAPIService) ProductsDestroyExecute(r ApiProductsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsAPIService.ProductsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/products/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiProductsGenerateReportCreateRequest struct {
	ctx context.Context
	ApiService ProductsAPI
	id int32
	reportGenerateOptionRequest *ReportGenerateOptionRequest
}

func (r ApiProductsGenerateReportCreateRequest) ReportGenerateOptionRequest(reportGenerateOptionRequest ReportGenerateOptionRequest) ApiProductsGenerateReportCreateRequest {
	r.reportGenerateOptionRequest = &reportGenerateOptionRequest
	return r
}

func (r ApiProductsGenerateReportCreateRequest) Execute() (*ReportGenerate, *http.Response, error) {
	return r.ApiService.ProductsGenerateReportCreateExecute(r)
}

/*
ProductsGenerateReportCreate Method for ProductsGenerateReportCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this product.
 @return ApiProductsGenerateReportCreateRequest
*/
func (a *ProductsAPIService) ProductsGenerateReportCreate(ctx context.Context, id int32) ApiProductsGenerateReportCreateRequest {
	return ApiProductsGenerateReportCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReportGenerate
func (a *ProductsAPIService) ProductsGenerateReportCreateExecute(r ApiProductsGenerateReportCreateRequest) (*ReportGenerate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportGenerate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsAPIService.ProductsGenerateReportCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/products/{id}/generate_report/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reportGenerateOptionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductsListRequest struct {
	ctx context.Context
	ApiService ProductsAPI
	businessCriticality *string
	created *time.Time
	description *string
	externalAudience *bool
	hasTags *bool
	id *[]int32
	internetAccessible *bool
	lifecycle *string
	limit *int32
	name *string
	nameExact *string
	notTag *string
	notTags *[]string
	o *[]string
	offset *int32
	origin *string
	outsideOfSla *float32
	platform *string
	prefetch *[]string
	prodNumericGrade *[]int32
	prodType *[]int32
	productManager *[]int32
	regulations *[]int32
	revenue *float32
	tag *string
	tags *[]string
	teamManager *[]int32
	technicalContact *[]int32
	tid *[]int32
	updated *time.Time
	userRecords *[]int32
}

func (r ApiProductsListRequest) BusinessCriticality(businessCriticality string) ApiProductsListRequest {
	r.businessCriticality = &businessCriticality
	return r
}

// * &#x60;None&#x60; - Any date * &#x60;1&#x60; - Today * &#x60;2&#x60; - Past 7 days * &#x60;3&#x60; - Past 30 days * &#x60;4&#x60; - Past 90 days * &#x60;5&#x60; - Current month * &#x60;6&#x60; - Current year * &#x60;7&#x60; - Past year
func (r ApiProductsListRequest) Created(created time.Time) ApiProductsListRequest {
	r.created = &created
	return r
}

func (r ApiProductsListRequest) Description(description string) ApiProductsListRequest {
	r.description = &description
	return r
}

func (r ApiProductsListRequest) ExternalAudience(externalAudience bool) ApiProductsListRequest {
	r.externalAudience = &externalAudience
	return r
}

// Has tags
func (r ApiProductsListRequest) HasTags(hasTags bool) ApiProductsListRequest {
	r.hasTags = &hasTags
	return r
}

// Multiple values may be separated by commas.
func (r ApiProductsListRequest) Id(id []int32) ApiProductsListRequest {
	r.id = &id
	return r
}

func (r ApiProductsListRequest) InternetAccessible(internetAccessible bool) ApiProductsListRequest {
	r.internetAccessible = &internetAccessible
	return r
}

func (r ApiProductsListRequest) Lifecycle(lifecycle string) ApiProductsListRequest {
	r.lifecycle = &lifecycle
	return r
}

// Number of results to return per page.
func (r ApiProductsListRequest) Limit(limit int32) ApiProductsListRequest {
	r.limit = &limit
	return r
}

func (r ApiProductsListRequest) Name(name string) ApiProductsListRequest {
	r.name = &name
	return r
}

func (r ApiProductsListRequest) NameExact(nameExact string) ApiProductsListRequest {
	r.nameExact = &nameExact
	return r
}

// Not Tag name contains
func (r ApiProductsListRequest) NotTag(notTag string) ApiProductsListRequest {
	r.notTag = &notTag
	return r
}

// Comma separated list of exact tags not present on product
func (r ApiProductsListRequest) NotTags(notTags []string) ApiProductsListRequest {
	r.notTags = &notTags
	return r
}

// Ordering  * &#x60;id&#x60; - Id * &#x60;-id&#x60; - Id (descending) * &#x60;tid&#x60; - Tid * &#x60;-tid&#x60; - Tid (descending) * &#x60;name&#x60; - Name * &#x60;-name&#x60; - Name (descending) * &#x60;created&#x60; - Created * &#x60;-created&#x60; - Created (descending) * &#x60;prod_numeric_grade&#x60; - Prod numeric grade * &#x60;-prod_numeric_grade&#x60; - Prod numeric grade (descending) * &#x60;business_criticality&#x60; - Business criticality * &#x60;-business_criticality&#x60; - Business criticality (descending) * &#x60;platform&#x60; - Platform * &#x60;-platform&#x60; - Platform (descending) * &#x60;lifecycle&#x60; - Lifecycle * &#x60;-lifecycle&#x60; - Lifecycle (descending) * &#x60;origin&#x60; - Origin * &#x60;-origin&#x60; - Origin (descending) * &#x60;revenue&#x60; - Revenue * &#x60;-revenue&#x60; - Revenue (descending) * &#x60;external_audience&#x60; - External audience * &#x60;-external_audience&#x60; - External audience (descending) * &#x60;internet_accessible&#x60; - Internet accessible * &#x60;-internet_accessible&#x60; - Internet accessible (descending) * &#x60;product_manager&#x60; - Product manager * &#x60;-product_manager&#x60; - Product manager (descending) * &#x60;product_manager__first_name&#x60; - Product manager  first name * &#x60;-product_manager__first_name&#x60; - Product manager  first name (descending) * &#x60;product_manager__last_name&#x60; - Product manager  last name * &#x60;-product_manager__last_name&#x60; - Product manager  last name (descending) * &#x60;technical_contact&#x60; - Technical contact * &#x60;-technical_contact&#x60; - Technical contact (descending) * &#x60;technical_contact__first_name&#x60; - Technical contact  first name * &#x60;-technical_contact__first_name&#x60; - Technical contact  first name (descending) * &#x60;technical_contact__last_name&#x60; - Technical contact  last name * &#x60;-technical_contact__last_name&#x60; - Technical contact  last name (descending) * &#x60;team_manager&#x60; - Team manager * &#x60;-team_manager&#x60; - Team manager (descending) * &#x60;team_manager__first_name&#x60; - Team manager  first name * &#x60;-team_manager__first_name&#x60; - Team manager  first name (descending) * &#x60;team_manager__last_name&#x60; - Team manager  last name * &#x60;-team_manager__last_name&#x60; - Team manager  last name (descending) * &#x60;prod_type&#x60; - Prod type * &#x60;-prod_type&#x60; - Prod type (descending) * &#x60;prod_type__name&#x60; - Prod type  name * &#x60;-prod_type__name&#x60; - Prod type  name (descending) * &#x60;updated&#x60; - Updated * &#x60;-updated&#x60; - Updated (descending) * &#x60;user_records&#x60; - User records * &#x60;-user_records&#x60; - User records (descending)
func (r ApiProductsListRequest) O(o []string) ApiProductsListRequest {
	r.o = &o
	return r
}

// The initial index from which to return the results.
func (r ApiProductsListRequest) Offset(offset int32) ApiProductsListRequest {
	r.offset = &offset
	return r
}

func (r ApiProductsListRequest) Origin(origin string) ApiProductsListRequest {
	r.origin = &origin
	return r
}

func (r ApiProductsListRequest) OutsideOfSla(outsideOfSla float32) ApiProductsListRequest {
	r.outsideOfSla = &outsideOfSla
	return r
}

func (r ApiProductsListRequest) Platform(platform string) ApiProductsListRequest {
	r.platform = &platform
	return r
}

// List of fields for which to prefetch model instances and add those to the response
func (r ApiProductsListRequest) Prefetch(prefetch []string) ApiProductsListRequest {
	r.prefetch = &prefetch
	return r
}

// Multiple values may be separated by commas.
func (r ApiProductsListRequest) ProdNumericGrade(prodNumericGrade []int32) ApiProductsListRequest {
	r.prodNumericGrade = &prodNumericGrade
	return r
}

// Multiple values may be separated by commas.
func (r ApiProductsListRequest) ProdType(prodType []int32) ApiProductsListRequest {
	r.prodType = &prodType
	return r
}

// Multiple values may be separated by commas.
func (r ApiProductsListRequest) ProductManager(productManager []int32) ApiProductsListRequest {
	r.productManager = &productManager
	return r
}

// Multiple values may be separated by commas.
func (r ApiProductsListRequest) Regulations(regulations []int32) ApiProductsListRequest {
	r.regulations = &regulations
	return r
}

func (r ApiProductsListRequest) Revenue(revenue float32) ApiProductsListRequest {
	r.revenue = &revenue
	return r
}

// Tag name contains
func (r ApiProductsListRequest) Tag(tag string) ApiProductsListRequest {
	r.tag = &tag
	return r
}

// Comma separated list of exact tags
func (r ApiProductsListRequest) Tags(tags []string) ApiProductsListRequest {
	r.tags = &tags
	return r
}

// Multiple values may be separated by commas.
func (r ApiProductsListRequest) TeamManager(teamManager []int32) ApiProductsListRequest {
	r.teamManager = &teamManager
	return r
}

// Multiple values may be separated by commas.
func (r ApiProductsListRequest) TechnicalContact(technicalContact []int32) ApiProductsListRequest {
	r.technicalContact = &technicalContact
	return r
}

// Multiple values may be separated by commas.
func (r ApiProductsListRequest) Tid(tid []int32) ApiProductsListRequest {
	r.tid = &tid
	return r
}

// * &#x60;None&#x60; - Any date * &#x60;1&#x60; - Today * &#x60;2&#x60; - Past 7 days * &#x60;3&#x60; - Past 30 days * &#x60;4&#x60; - Past 90 days * &#x60;5&#x60; - Current month * &#x60;6&#x60; - Current year * &#x60;7&#x60; - Past year
func (r ApiProductsListRequest) Updated(updated time.Time) ApiProductsListRequest {
	r.updated = &updated
	return r
}

// Multiple values may be separated by commas.
func (r ApiProductsListRequest) UserRecords(userRecords []int32) ApiProductsListRequest {
	r.userRecords = &userRecords
	return r
}

func (r ApiProductsListRequest) Execute() (*PaginatedProductList, *http.Response, error) {
	return r.ApiService.ProductsListExecute(r)
}

/*
ProductsList Method for ProductsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductsListRequest
*/
func (a *ProductsAPIService) ProductsList(ctx context.Context) ApiProductsListRequest {
	return ApiProductsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedProductList
func (a *ProductsAPIService) ProductsListExecute(r ApiProductsListRequest) (*PaginatedProductList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedProductList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsAPIService.ProductsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/products/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.businessCriticality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "business_criticality", r.businessCriticality, "")
	}
	if r.created != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created", r.created, "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.externalAudience != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "external_audience", r.externalAudience, "")
	}
	if r.hasTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_tags", r.hasTags, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "csv")
	}
	if r.internetAccessible != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internet_accessible", r.internetAccessible, "")
	}
	if r.lifecycle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lifecycle", r.lifecycle, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.nameExact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name_exact", r.nameExact, "")
	}
	if r.notTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_tag", r.notTag, "")
	}
	if r.notTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_tags", r.notTags, "csv")
	}
	if r.o != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "o", r.o, "csv")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.origin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origin", r.origin, "")
	}
	if r.outsideOfSla != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outside_of_sla", r.outsideOfSla, "")
	}
	if r.platform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "platform", r.platform, "")
	}
	if r.prefetch != nil {
		t := *r.prefetch
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefetch", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefetch", t, "multi")
		}
	}
	if r.prodNumericGrade != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prod_numeric_grade", r.prodNumericGrade, "csv")
	}
	if r.prodType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prod_type", r.prodType, "csv")
	}
	if r.productManager != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_manager", r.productManager, "csv")
	}
	if r.regulations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regulations", r.regulations, "csv")
	}
	if r.revenue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revenue", r.revenue, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "csv")
	}
	if r.teamManager != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "team_manager", r.teamManager, "csv")
	}
	if r.technicalContact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "technical_contact", r.technicalContact, "csv")
	}
	if r.tid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tid", r.tid, "csv")
	}
	if r.updated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated", r.updated, "")
	}
	if r.userRecords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_records", r.userRecords, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductsPartialUpdateRequest struct {
	ctx context.Context
	ApiService ProductsAPI
	id int32
	patchedProductRequest *PatchedProductRequest
}

func (r ApiProductsPartialUpdateRequest) PatchedProductRequest(patchedProductRequest PatchedProductRequest) ApiProductsPartialUpdateRequest {
	r.patchedProductRequest = &patchedProductRequest
	return r
}

func (r ApiProductsPartialUpdateRequest) Execute() (*Product, *http.Response, error) {
	return r.ApiService.ProductsPartialUpdateExecute(r)
}

/*
ProductsPartialUpdate Method for ProductsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this product.
 @return ApiProductsPartialUpdateRequest
*/
func (a *ProductsAPIService) ProductsPartialUpdate(ctx context.Context, id int32) ApiProductsPartialUpdateRequest {
	return ApiProductsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Product
func (a *ProductsAPIService) ProductsPartialUpdateExecute(r ApiProductsPartialUpdateRequest) (*Product, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Product
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsAPIService.ProductsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/products/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedProductRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductsRetrieveRequest struct {
	ctx context.Context
	ApiService ProductsAPI
	id int32
	prefetch *[]string
}

// List of fields for which to prefetch model instances and add those to the response
func (r ApiProductsRetrieveRequest) Prefetch(prefetch []string) ApiProductsRetrieveRequest {
	r.prefetch = &prefetch
	return r
}

func (r ApiProductsRetrieveRequest) Execute() (*Product, *http.Response, error) {
	return r.ApiService.ProductsRetrieveExecute(r)
}

/*
ProductsRetrieve Method for ProductsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this product.
 @return ApiProductsRetrieveRequest
*/
func (a *ProductsAPIService) ProductsRetrieve(ctx context.Context, id int32) ApiProductsRetrieveRequest {
	return ApiProductsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Product
func (a *ProductsAPIService) ProductsRetrieveExecute(r ApiProductsRetrieveRequest) (*Product, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Product
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsAPIService.ProductsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/products/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.prefetch != nil {
		t := *r.prefetch
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefetch", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefetch", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductsUpdateRequest struct {
	ctx context.Context
	ApiService ProductsAPI
	id int32
	productRequest *ProductRequest
}

func (r ApiProductsUpdateRequest) ProductRequest(productRequest ProductRequest) ApiProductsUpdateRequest {
	r.productRequest = &productRequest
	return r
}

func (r ApiProductsUpdateRequest) Execute() (*Product, *http.Response, error) {
	return r.ApiService.ProductsUpdateExecute(r)
}

/*
ProductsUpdate Method for ProductsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this product.
 @return ApiProductsUpdateRequest
*/
func (a *ProductsAPIService) ProductsUpdate(ctx context.Context, id int32) ApiProductsUpdateRequest {
	return ApiProductsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Product
func (a *ProductsAPIService) ProductsUpdateExecute(r ApiProductsUpdateRequest) (*Product, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Product
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsAPIService.ProductsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/products/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productRequest == nil {
		return localVarReturnValue, nil, reportError("productRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
