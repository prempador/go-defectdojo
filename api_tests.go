/*
Defect Dojo API v2

Defect Dojo - Open Source vulnerability Management made easy. Prefetch related parameters/responses not yet in the schema.

API version: 2.30.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
	"time"
)


type TestsAPI interface {

	/*
	TestsAcceptRisksCreate Method for TestsAcceptRisksCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this test.
	@return ApiTestsAcceptRisksCreateRequest
	*/
	TestsAcceptRisksCreate(ctx context.Context, id int32) ApiTestsAcceptRisksCreateRequest

	// TestsAcceptRisksCreateExecute executes the request
	//  @return []RiskAcceptance
	TestsAcceptRisksCreateExecute(r ApiTestsAcceptRisksCreateRequest) ([]RiskAcceptance, *http.Response, error)

	/*
	TestsCreate Method for TestsCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestsCreateRequest
	*/
	TestsCreate(ctx context.Context) ApiTestsCreateRequest

	// TestsCreateExecute executes the request
	//  @return TestCreate
	TestsCreateExecute(r ApiTestsCreateRequest) (*TestCreate, *http.Response, error)

	/*
	TestsDeletePreviewList Method for TestsDeletePreviewList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this test.
	@return ApiTestsDeletePreviewListRequest
	*/
	TestsDeletePreviewList(ctx context.Context, id int32) ApiTestsDeletePreviewListRequest

	// TestsDeletePreviewListExecute executes the request
	//  @return PaginatedDeletePreviewList
	TestsDeletePreviewListExecute(r ApiTestsDeletePreviewListRequest) (*PaginatedDeletePreviewList, *http.Response, error)

	/*
	TestsDestroy Method for TestsDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this test.
	@return ApiTestsDestroyRequest
	*/
	TestsDestroy(ctx context.Context, id int32) ApiTestsDestroyRequest

	// TestsDestroyExecute executes the request
	TestsDestroyExecute(r ApiTestsDestroyRequest) (*http.Response, error)

	/*
	TestsFilesCreate Method for TestsFilesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this test.
	@return ApiTestsFilesCreateRequest
	*/
	TestsFilesCreate(ctx context.Context, id int32) ApiTestsFilesCreateRequest

	// TestsFilesCreateExecute executes the request
	//  @return File
	TestsFilesCreateExecute(r ApiTestsFilesCreateRequest) (*File, *http.Response, error)

	/*
	TestsFilesDownloadRetrieve Method for TestsFilesDownloadRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fileId
	@param id A unique integer value identifying this test.
	@return ApiTestsFilesDownloadRetrieveRequest
	*/
	TestsFilesDownloadRetrieve(ctx context.Context, fileId string, id int32) ApiTestsFilesDownloadRetrieveRequest

	// TestsFilesDownloadRetrieveExecute executes the request
	//  @return RawFile
	TestsFilesDownloadRetrieveExecute(r ApiTestsFilesDownloadRetrieveRequest) (*RawFile, *http.Response, error)

	/*
	TestsFilesRetrieve Method for TestsFilesRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this test.
	@return ApiTestsFilesRetrieveRequest
	*/
	TestsFilesRetrieve(ctx context.Context, id int32) ApiTestsFilesRetrieveRequest

	// TestsFilesRetrieveExecute executes the request
	//  @return TestToFiles
	TestsFilesRetrieveExecute(r ApiTestsFilesRetrieveRequest) (*TestToFiles, *http.Response, error)

	/*
	TestsGenerateReportCreate Method for TestsGenerateReportCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this test.
	@return ApiTestsGenerateReportCreateRequest
	*/
	TestsGenerateReportCreate(ctx context.Context, id int32) ApiTestsGenerateReportCreateRequest

	// TestsGenerateReportCreateExecute executes the request
	//  @return ReportGenerate
	TestsGenerateReportCreateExecute(r ApiTestsGenerateReportCreateRequest) (*ReportGenerate, *http.Response, error)

	/*
	TestsList Method for TestsList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestsListRequest
	*/
	TestsList(ctx context.Context) ApiTestsListRequest

	// TestsListExecute executes the request
	//  @return PaginatedTestList
	TestsListExecute(r ApiTestsListRequest) (*PaginatedTestList, *http.Response, error)

	/*
	TestsNotesCreate Method for TestsNotesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this test.
	@return ApiTestsNotesCreateRequest
	*/
	TestsNotesCreate(ctx context.Context, id int32) ApiTestsNotesCreateRequest

	// TestsNotesCreateExecute executes the request
	//  @return Note
	TestsNotesCreateExecute(r ApiTestsNotesCreateRequest) (*Note, *http.Response, error)

	/*
	TestsNotesRetrieve Method for TestsNotesRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this test.
	@return ApiTestsNotesRetrieveRequest
	*/
	TestsNotesRetrieve(ctx context.Context, id int32) ApiTestsNotesRetrieveRequest

	// TestsNotesRetrieveExecute executes the request
	//  @return TestToNotes
	TestsNotesRetrieveExecute(r ApiTestsNotesRetrieveRequest) (*TestToNotes, *http.Response, error)

	/*
	TestsPartialUpdate Method for TestsPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this test.
	@return ApiTestsPartialUpdateRequest
	*/
	TestsPartialUpdate(ctx context.Context, id int32) ApiTestsPartialUpdateRequest

	// TestsPartialUpdateExecute executes the request
	//  @return Test
	TestsPartialUpdateExecute(r ApiTestsPartialUpdateRequest) (*Test, *http.Response, error)

	/*
	TestsRetrieve Method for TestsRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this test.
	@return ApiTestsRetrieveRequest
	*/
	TestsRetrieve(ctx context.Context, id int32) ApiTestsRetrieveRequest

	// TestsRetrieveExecute executes the request
	//  @return Test
	TestsRetrieveExecute(r ApiTestsRetrieveRequest) (*Test, *http.Response, error)

	/*
	TestsUpdate Method for TestsUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this test.
	@return ApiTestsUpdateRequest
	*/
	TestsUpdate(ctx context.Context, id int32) ApiTestsUpdateRequest

	// TestsUpdateExecute executes the request
	//  @return Test
	TestsUpdateExecute(r ApiTestsUpdateRequest) (*Test, *http.Response, error)
}

// TestsAPIService TestsAPI service
type TestsAPIService service

type ApiTestsAcceptRisksCreateRequest struct {
	ctx context.Context
	ApiService TestsAPI
	id int32
	acceptedRiskRequest *[]AcceptedRiskRequest
}

func (r ApiTestsAcceptRisksCreateRequest) AcceptedRiskRequest(acceptedRiskRequest []AcceptedRiskRequest) ApiTestsAcceptRisksCreateRequest {
	r.acceptedRiskRequest = &acceptedRiskRequest
	return r
}

func (r ApiTestsAcceptRisksCreateRequest) Execute() ([]RiskAcceptance, *http.Response, error) {
	return r.ApiService.TestsAcceptRisksCreateExecute(r)
}

/*
TestsAcceptRisksCreate Method for TestsAcceptRisksCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this test.
 @return ApiTestsAcceptRisksCreateRequest
*/
func (a *TestsAPIService) TestsAcceptRisksCreate(ctx context.Context, id int32) ApiTestsAcceptRisksCreateRequest {
	return ApiTestsAcceptRisksCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []RiskAcceptance
func (a *TestsAPIService) TestsAcceptRisksCreateExecute(r ApiTestsAcceptRisksCreateRequest) ([]RiskAcceptance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RiskAcceptance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestsAPIService.TestsAcceptRisksCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tests/{id}/accept_risks/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.acceptedRiskRequest == nil {
		return localVarReturnValue, nil, reportError("acceptedRiskRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.acceptedRiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestsCreateRequest struct {
	ctx context.Context
	ApiService TestsAPI
	testCreateRequest *TestCreateRequest
}

func (r ApiTestsCreateRequest) TestCreateRequest(testCreateRequest TestCreateRequest) ApiTestsCreateRequest {
	r.testCreateRequest = &testCreateRequest
	return r
}

func (r ApiTestsCreateRequest) Execute() (*TestCreate, *http.Response, error) {
	return r.ApiService.TestsCreateExecute(r)
}

/*
TestsCreate Method for TestsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestsCreateRequest
*/
func (a *TestsAPIService) TestsCreate(ctx context.Context) ApiTestsCreateRequest {
	return ApiTestsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TestCreate
func (a *TestsAPIService) TestsCreateExecute(r ApiTestsCreateRequest) (*TestCreate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TestCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestsAPIService.TestsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tests/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.testCreateRequest == nil {
		return localVarReturnValue, nil, reportError("testCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.testCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestsDeletePreviewListRequest struct {
	ctx context.Context
	ApiService TestsAPI
	id int32
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiTestsDeletePreviewListRequest) Limit(limit int32) ApiTestsDeletePreviewListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiTestsDeletePreviewListRequest) Offset(offset int32) ApiTestsDeletePreviewListRequest {
	r.offset = &offset
	return r
}

func (r ApiTestsDeletePreviewListRequest) Execute() (*PaginatedDeletePreviewList, *http.Response, error) {
	return r.ApiService.TestsDeletePreviewListExecute(r)
}

/*
TestsDeletePreviewList Method for TestsDeletePreviewList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this test.
 @return ApiTestsDeletePreviewListRequest
*/
func (a *TestsAPIService) TestsDeletePreviewList(ctx context.Context, id int32) ApiTestsDeletePreviewListRequest {
	return ApiTestsDeletePreviewListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedDeletePreviewList
func (a *TestsAPIService) TestsDeletePreviewListExecute(r ApiTestsDeletePreviewListRequest) (*PaginatedDeletePreviewList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeletePreviewList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestsAPIService.TestsDeletePreviewList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tests/{id}/delete_preview/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestsDestroyRequest struct {
	ctx context.Context
	ApiService TestsAPI
	id int32
}

func (r ApiTestsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.TestsDestroyExecute(r)
}

/*
TestsDestroy Method for TestsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this test.
 @return ApiTestsDestroyRequest
*/
func (a *TestsAPIService) TestsDestroy(ctx context.Context, id int32) ApiTestsDestroyRequest {
	return ApiTestsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *TestsAPIService) TestsDestroyExecute(r ApiTestsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestsAPIService.TestsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tests/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestsFilesCreateRequest struct {
	ctx context.Context
	ApiService TestsAPI
	id int32
	title *string
	file *os.File
}

func (r ApiTestsFilesCreateRequest) Title(title string) ApiTestsFilesCreateRequest {
	r.title = &title
	return r
}

func (r ApiTestsFilesCreateRequest) File(file *os.File) ApiTestsFilesCreateRequest {
	r.file = file
	return r
}

func (r ApiTestsFilesCreateRequest) Execute() (*File, *http.Response, error) {
	return r.ApiService.TestsFilesCreateExecute(r)
}

/*
TestsFilesCreate Method for TestsFilesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this test.
 @return ApiTestsFilesCreateRequest
*/
func (a *TestsAPIService) TestsFilesCreate(ctx context.Context, id int32) ApiTestsFilesCreateRequest {
	return ApiTestsFilesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return File
func (a *TestsAPIService) TestsFilesCreateExecute(r ApiTestsFilesCreateRequest) (*File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestsAPIService.TestsFilesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tests/{id}/files/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if strlen(*r.title) < 1 {
		return localVarReturnValue, nil, reportError("title must have at least 1 elements")
	}
	if strlen(*r.title) > 100 {
		return localVarReturnValue, nil, reportError("title must have less than 100 elements")
	}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "")
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestsFilesDownloadRetrieveRequest struct {
	ctx context.Context
	ApiService TestsAPI
	fileId string
	id int32
}

func (r ApiTestsFilesDownloadRetrieveRequest) Execute() (*RawFile, *http.Response, error) {
	return r.ApiService.TestsFilesDownloadRetrieveExecute(r)
}

/*
TestsFilesDownloadRetrieve Method for TestsFilesDownloadRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileId
 @param id A unique integer value identifying this test.
 @return ApiTestsFilesDownloadRetrieveRequest
*/
func (a *TestsAPIService) TestsFilesDownloadRetrieve(ctx context.Context, fileId string, id int32) ApiTestsFilesDownloadRetrieveRequest {
	return ApiTestsFilesDownloadRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
		id: id,
	}
}

// Execute executes the request
//  @return RawFile
func (a *TestsAPIService) TestsFilesDownloadRetrieveExecute(r ApiTestsFilesDownloadRetrieveRequest) (*RawFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RawFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestsAPIService.TestsFilesDownloadRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tests/{id}/files/download/{file_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"file_id"+"}", url.PathEscape(parameterValueToString(r.fileId, "fileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestsFilesRetrieveRequest struct {
	ctx context.Context
	ApiService TestsAPI
	id int32
}

func (r ApiTestsFilesRetrieveRequest) Execute() (*TestToFiles, *http.Response, error) {
	return r.ApiService.TestsFilesRetrieveExecute(r)
}

/*
TestsFilesRetrieve Method for TestsFilesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this test.
 @return ApiTestsFilesRetrieveRequest
*/
func (a *TestsAPIService) TestsFilesRetrieve(ctx context.Context, id int32) ApiTestsFilesRetrieveRequest {
	return ApiTestsFilesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TestToFiles
func (a *TestsAPIService) TestsFilesRetrieveExecute(r ApiTestsFilesRetrieveRequest) (*TestToFiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TestToFiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestsAPIService.TestsFilesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tests/{id}/files/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestsGenerateReportCreateRequest struct {
	ctx context.Context
	ApiService TestsAPI
	id int32
	reportGenerateOptionRequest *ReportGenerateOptionRequest
}

func (r ApiTestsGenerateReportCreateRequest) ReportGenerateOptionRequest(reportGenerateOptionRequest ReportGenerateOptionRequest) ApiTestsGenerateReportCreateRequest {
	r.reportGenerateOptionRequest = &reportGenerateOptionRequest
	return r
}

func (r ApiTestsGenerateReportCreateRequest) Execute() (*ReportGenerate, *http.Response, error) {
	return r.ApiService.TestsGenerateReportCreateExecute(r)
}

/*
TestsGenerateReportCreate Method for TestsGenerateReportCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this test.
 @return ApiTestsGenerateReportCreateRequest
*/
func (a *TestsAPIService) TestsGenerateReportCreate(ctx context.Context, id int32) ApiTestsGenerateReportCreateRequest {
	return ApiTestsGenerateReportCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReportGenerate
func (a *TestsAPIService) TestsGenerateReportCreateExecute(r ApiTestsGenerateReportCreateRequest) (*ReportGenerate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportGenerate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestsAPIService.TestsGenerateReportCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tests/{id}/generate_report/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reportGenerateOptionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestsListRequest struct {
	ctx context.Context
	ApiService TestsAPI
	actualTime *string
	apiScanConfiguration *int32
	branchTag *string
	buildId *string
	commitHash *string
	engagement *int32
	engagementProductTags *[]string
	engagementTags *[]string
	hasTags *bool
	id *int32
	limit *int32
	notEngagementProductTags *[]string
	notEngagementTags *[]string
	notTag *string
	notTags *[]string
	notes *[]int32
	o *[]string
	offset *int32
	percentComplete *int32
	scanType *string
	tag *string
	tags *[]string
	targetEnd *time.Time
	targetStart *time.Time
	testType *int32
	title *string
	version *string
}

func (r ApiTestsListRequest) ActualTime(actualTime string) ApiTestsListRequest {
	r.actualTime = &actualTime
	return r
}

func (r ApiTestsListRequest) ApiScanConfiguration(apiScanConfiguration int32) ApiTestsListRequest {
	r.apiScanConfiguration = &apiScanConfiguration
	return r
}

func (r ApiTestsListRequest) BranchTag(branchTag string) ApiTestsListRequest {
	r.branchTag = &branchTag
	return r
}

func (r ApiTestsListRequest) BuildId(buildId string) ApiTestsListRequest {
	r.buildId = &buildId
	return r
}

func (r ApiTestsListRequest) CommitHash(commitHash string) ApiTestsListRequest {
	r.commitHash = &commitHash
	return r
}

func (r ApiTestsListRequest) Engagement(engagement int32) ApiTestsListRequest {
	r.engagement = &engagement
	return r
}

// Comma separated list of exact tags present on product
func (r ApiTestsListRequest) EngagementProductTags(engagementProductTags []string) ApiTestsListRequest {
	r.engagementProductTags = &engagementProductTags
	return r
}

// Comma separated list of exact tags present on engagement
func (r ApiTestsListRequest) EngagementTags(engagementTags []string) ApiTestsListRequest {
	r.engagementTags = &engagementTags
	return r
}

// Has tags
func (r ApiTestsListRequest) HasTags(hasTags bool) ApiTestsListRequest {
	r.hasTags = &hasTags
	return r
}

func (r ApiTestsListRequest) Id(id int32) ApiTestsListRequest {
	r.id = &id
	return r
}

// Number of results to return per page.
func (r ApiTestsListRequest) Limit(limit int32) ApiTestsListRequest {
	r.limit = &limit
	return r
}

// Comma separated list of exact tags not present on product
func (r ApiTestsListRequest) NotEngagementProductTags(notEngagementProductTags []string) ApiTestsListRequest {
	r.notEngagementProductTags = &notEngagementProductTags
	return r
}

// Comma separated list of exact tags not present on engagement
func (r ApiTestsListRequest) NotEngagementTags(notEngagementTags []string) ApiTestsListRequest {
	r.notEngagementTags = &notEngagementTags
	return r
}

// Not Tag name contains
func (r ApiTestsListRequest) NotTag(notTag string) ApiTestsListRequest {
	r.notTag = &notTag
	return r
}

// Comma separated list of exact tags not present on model
func (r ApiTestsListRequest) NotTags(notTags []string) ApiTestsListRequest {
	r.notTags = &notTags
	return r
}

func (r ApiTestsListRequest) Notes(notes []int32) ApiTestsListRequest {
	r.notes = &notes
	return r
}

// Ordering  * &#x60;title&#x60; - Title * &#x60;-title&#x60; - Title (descending) * &#x60;version&#x60; - Version * &#x60;-version&#x60; - Version (descending) * &#x60;target_start&#x60; - Target start * &#x60;-target_start&#x60; - Target start (descending) * &#x60;target_end&#x60; - Target end * &#x60;-target_end&#x60; - Target end (descending) * &#x60;test_type&#x60; - Test type * &#x60;-test_type&#x60; - Test type (descending) * &#x60;lead&#x60; - Lead * &#x60;-lead&#x60; - Lead (descending) * &#x60;branch_tag&#x60; - Branch tag * &#x60;-branch_tag&#x60; - Branch tag (descending) * &#x60;build_id&#x60; - Build id * &#x60;-build_id&#x60; - Build id (descending) * &#x60;commit_hash&#x60; - Commit hash * &#x60;-commit_hash&#x60; - Commit hash (descending) * &#x60;api_scan_configuration&#x60; - Api scan configuration * &#x60;-api_scan_configuration&#x60; - Api scan configuration (descending) * &#x60;engagement&#x60; - Engagement * &#x60;-engagement&#x60; - Engagement (descending) * &#x60;created&#x60; - Created * &#x60;-created&#x60; - Created (descending) * &#x60;updated&#x60; - Updated * &#x60;-updated&#x60; - Updated (descending)
func (r ApiTestsListRequest) O(o []string) ApiTestsListRequest {
	r.o = &o
	return r
}

// The initial index from which to return the results.
func (r ApiTestsListRequest) Offset(offset int32) ApiTestsListRequest {
	r.offset = &offset
	return r
}

func (r ApiTestsListRequest) PercentComplete(percentComplete int32) ApiTestsListRequest {
	r.percentComplete = &percentComplete
	return r
}

func (r ApiTestsListRequest) ScanType(scanType string) ApiTestsListRequest {
	r.scanType = &scanType
	return r
}

// Tag name contains
func (r ApiTestsListRequest) Tag(tag string) ApiTestsListRequest {
	r.tag = &tag
	return r
}

// Comma separated list of exact tags
func (r ApiTestsListRequest) Tags(tags []string) ApiTestsListRequest {
	r.tags = &tags
	return r
}

func (r ApiTestsListRequest) TargetEnd(targetEnd time.Time) ApiTestsListRequest {
	r.targetEnd = &targetEnd
	return r
}

func (r ApiTestsListRequest) TargetStart(targetStart time.Time) ApiTestsListRequest {
	r.targetStart = &targetStart
	return r
}

func (r ApiTestsListRequest) TestType(testType int32) ApiTestsListRequest {
	r.testType = &testType
	return r
}

func (r ApiTestsListRequest) Title(title string) ApiTestsListRequest {
	r.title = &title
	return r
}

func (r ApiTestsListRequest) Version(version string) ApiTestsListRequest {
	r.version = &version
	return r
}

func (r ApiTestsListRequest) Execute() (*PaginatedTestList, *http.Response, error) {
	return r.ApiService.TestsListExecute(r)
}

/*
TestsList Method for TestsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestsListRequest
*/
func (a *TestsAPIService) TestsList(ctx context.Context) ApiTestsListRequest {
	return ApiTestsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedTestList
func (a *TestsAPIService) TestsListExecute(r ApiTestsListRequest) (*PaginatedTestList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedTestList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestsAPIService.TestsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tests/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.actualTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actual_time", r.actualTime, "")
	}
	if r.apiScanConfiguration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api_scan_configuration", r.apiScanConfiguration, "")
	}
	if r.branchTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "branch_tag", r.branchTag, "")
	}
	if r.buildId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "build_id", r.buildId, "")
	}
	if r.commitHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "commit_hash", r.commitHash, "")
	}
	if r.engagement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "engagement", r.engagement, "")
	}
	if r.engagementProductTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "engagement__product__tags", r.engagementProductTags, "csv")
	}
	if r.engagementTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "engagement__tags", r.engagementTags, "csv")
	}
	if r.hasTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_tags", r.hasTags, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.notEngagementProductTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_engagement__product__tags", r.notEngagementProductTags, "csv")
	}
	if r.notEngagementTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_engagement__tags", r.notEngagementTags, "csv")
	}
	if r.notTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_tag", r.notTag, "")
	}
	if r.notTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_tags", r.notTags, "csv")
	}
	if r.notes != nil {
		t := *r.notes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "notes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "notes", t, "multi")
		}
	}
	if r.o != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "o", r.o, "csv")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.percentComplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percent_complete", r.percentComplete, "")
	}
	if r.scanType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scan_type", r.scanType, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "csv")
	}
	if r.targetEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_end", r.targetEnd, "")
	}
	if r.targetStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_start", r.targetStart, "")
	}
	if r.testType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test_type", r.testType, "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestsNotesCreateRequest struct {
	ctx context.Context
	ApiService TestsAPI
	id int32
	addNewNoteOptionRequest *AddNewNoteOptionRequest
}

func (r ApiTestsNotesCreateRequest) AddNewNoteOptionRequest(addNewNoteOptionRequest AddNewNoteOptionRequest) ApiTestsNotesCreateRequest {
	r.addNewNoteOptionRequest = &addNewNoteOptionRequest
	return r
}

func (r ApiTestsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.TestsNotesCreateExecute(r)
}

/*
TestsNotesCreate Method for TestsNotesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this test.
 @return ApiTestsNotesCreateRequest
*/
func (a *TestsAPIService) TestsNotesCreate(ctx context.Context, id int32) ApiTestsNotesCreateRequest {
	return ApiTestsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *TestsAPIService) TestsNotesCreateExecute(r ApiTestsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestsAPIService.TestsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tests/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addNewNoteOptionRequest == nil {
		return localVarReturnValue, nil, reportError("addNewNoteOptionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addNewNoteOptionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestsNotesRetrieveRequest struct {
	ctx context.Context
	ApiService TestsAPI
	id int32
}

func (r ApiTestsNotesRetrieveRequest) Execute() (*TestToNotes, *http.Response, error) {
	return r.ApiService.TestsNotesRetrieveExecute(r)
}

/*
TestsNotesRetrieve Method for TestsNotesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this test.
 @return ApiTestsNotesRetrieveRequest
*/
func (a *TestsAPIService) TestsNotesRetrieve(ctx context.Context, id int32) ApiTestsNotesRetrieveRequest {
	return ApiTestsNotesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TestToNotes
func (a *TestsAPIService) TestsNotesRetrieveExecute(r ApiTestsNotesRetrieveRequest) (*TestToNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TestToNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestsAPIService.TestsNotesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tests/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestsPartialUpdateRequest struct {
	ctx context.Context
	ApiService TestsAPI
	id int32
	patchedTestRequest *PatchedTestRequest
}

func (r ApiTestsPartialUpdateRequest) PatchedTestRequest(patchedTestRequest PatchedTestRequest) ApiTestsPartialUpdateRequest {
	r.patchedTestRequest = &patchedTestRequest
	return r
}

func (r ApiTestsPartialUpdateRequest) Execute() (*Test, *http.Response, error) {
	return r.ApiService.TestsPartialUpdateExecute(r)
}

/*
TestsPartialUpdate Method for TestsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this test.
 @return ApiTestsPartialUpdateRequest
*/
func (a *TestsAPIService) TestsPartialUpdate(ctx context.Context, id int32) ApiTestsPartialUpdateRequest {
	return ApiTestsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Test
func (a *TestsAPIService) TestsPartialUpdateExecute(r ApiTestsPartialUpdateRequest) (*Test, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Test
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestsAPIService.TestsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tests/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTestRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestsRetrieveRequest struct {
	ctx context.Context
	ApiService TestsAPI
	id int32
}

func (r ApiTestsRetrieveRequest) Execute() (*Test, *http.Response, error) {
	return r.ApiService.TestsRetrieveExecute(r)
}

/*
TestsRetrieve Method for TestsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this test.
 @return ApiTestsRetrieveRequest
*/
func (a *TestsAPIService) TestsRetrieve(ctx context.Context, id int32) ApiTestsRetrieveRequest {
	return ApiTestsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Test
func (a *TestsAPIService) TestsRetrieveExecute(r ApiTestsRetrieveRequest) (*Test, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Test
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestsAPIService.TestsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tests/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestsUpdateRequest struct {
	ctx context.Context
	ApiService TestsAPI
	id int32
	testRequest *TestRequest
}

func (r ApiTestsUpdateRequest) TestRequest(testRequest TestRequest) ApiTestsUpdateRequest {
	r.testRequest = &testRequest
	return r
}

func (r ApiTestsUpdateRequest) Execute() (*Test, *http.Response, error) {
	return r.ApiService.TestsUpdateExecute(r)
}

/*
TestsUpdate Method for TestsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this test.
 @return ApiTestsUpdateRequest
*/
func (a *TestsAPIService) TestsUpdate(ctx context.Context, id int32) ApiTestsUpdateRequest {
	return ApiTestsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Test
func (a *TestsAPIService) TestsUpdateExecute(r ApiTestsUpdateRequest) (*Test, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Test
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestsAPIService.TestsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/tests/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.testRequest == nil {
		return localVarReturnValue, nil, reportError("testRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.testRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
