/*
Defect Dojo API v2

Defect Dojo - Open Source vulnerability Management made easy. Prefetch related parameters/responses not yet in the schema.

API version: 2.38.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package defectdojo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
	"os"
)


type FindingsAPI interface {

	/*
	FindingsAcceptRisksCreate Method for FindingsAcceptRisksCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFindingsAcceptRisksCreateRequest
	*/
	FindingsAcceptRisksCreate(ctx context.Context) ApiFindingsAcceptRisksCreateRequest

	// FindingsAcceptRisksCreateExecute executes the request
	//  @return PaginatedRiskAcceptanceList
	FindingsAcceptRisksCreateExecute(r ApiFindingsAcceptRisksCreateRequest) (*PaginatedRiskAcceptanceList, *http.Response, error)

	/*
	FindingsCloseCreate Method for FindingsCloseCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsCloseCreateRequest
	*/
	FindingsCloseCreate(ctx context.Context, id int32) ApiFindingsCloseCreateRequest

	// FindingsCloseCreateExecute executes the request
	//  @return FindingClose
	FindingsCloseCreateExecute(r ApiFindingsCloseCreateRequest) (*FindingClose, *http.Response, error)

	/*
	FindingsCreate Method for FindingsCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFindingsCreateRequest
	*/
	FindingsCreate(ctx context.Context) ApiFindingsCreateRequest

	// FindingsCreateExecute executes the request
	//  @return FindingCreate
	FindingsCreateExecute(r ApiFindingsCreateRequest) (*FindingCreate, *http.Response, error)

	/*
	FindingsDeletePreviewList Method for FindingsDeletePreviewList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsDeletePreviewListRequest
	*/
	FindingsDeletePreviewList(ctx context.Context, id int32) ApiFindingsDeletePreviewListRequest

	// FindingsDeletePreviewListExecute executes the request
	//  @return PaginatedDeletePreviewList
	FindingsDeletePreviewListExecute(r ApiFindingsDeletePreviewListRequest) (*PaginatedDeletePreviewList, *http.Response, error)

	/*
	FindingsDestroy Method for FindingsDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsDestroyRequest
	*/
	FindingsDestroy(ctx context.Context, id int32) ApiFindingsDestroyRequest

	// FindingsDestroyExecute executes the request
	FindingsDestroyExecute(r ApiFindingsDestroyRequest) (*http.Response, error)

	/*
	FindingsDuplicateList Method for FindingsDuplicateList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsDuplicateListRequest
	*/
	FindingsDuplicateList(ctx context.Context, id int32) ApiFindingsDuplicateListRequest

	// FindingsDuplicateListExecute executes the request
	//  @return []Finding
	FindingsDuplicateListExecute(r ApiFindingsDuplicateListRequest) ([]Finding, *http.Response, error)

	/*
	FindingsDuplicateResetCreate Method for FindingsDuplicateResetCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsDuplicateResetCreateRequest
	*/
	FindingsDuplicateResetCreate(ctx context.Context, id int32) ApiFindingsDuplicateResetCreateRequest

	// FindingsDuplicateResetCreateExecute executes the request
	FindingsDuplicateResetCreateExecute(r ApiFindingsDuplicateResetCreateRequest) (*http.Response, error)

	/*
	FindingsFilesCreate Method for FindingsFilesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsFilesCreateRequest
	*/
	FindingsFilesCreate(ctx context.Context, id int32) ApiFindingsFilesCreateRequest

	// FindingsFilesCreateExecute executes the request
	//  @return File
	FindingsFilesCreateExecute(r ApiFindingsFilesCreateRequest) (*File, *http.Response, error)

	/*
	FindingsFilesDownloadRetrieve Method for FindingsFilesDownloadRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fileId
	@param id A unique integer value identifying this finding.
	@return ApiFindingsFilesDownloadRetrieveRequest
	*/
	FindingsFilesDownloadRetrieve(ctx context.Context, fileId string, id int32) ApiFindingsFilesDownloadRetrieveRequest

	// FindingsFilesDownloadRetrieveExecute executes the request
	//  @return RawFile
	FindingsFilesDownloadRetrieveExecute(r ApiFindingsFilesDownloadRetrieveRequest) (*RawFile, *http.Response, error)

	/*
	FindingsFilesRetrieve Method for FindingsFilesRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsFilesRetrieveRequest
	*/
	FindingsFilesRetrieve(ctx context.Context, id int32) ApiFindingsFilesRetrieveRequest

	// FindingsFilesRetrieveExecute executes the request
	//  @return FindingToFiles
	FindingsFilesRetrieveExecute(r ApiFindingsFilesRetrieveRequest) (*FindingToFiles, *http.Response, error)

	/*
	FindingsGenerateReportCreate Method for FindingsGenerateReportCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFindingsGenerateReportCreateRequest
	*/
	FindingsGenerateReportCreate(ctx context.Context) ApiFindingsGenerateReportCreateRequest

	// FindingsGenerateReportCreateExecute executes the request
	//  @return ReportGenerate
	FindingsGenerateReportCreateExecute(r ApiFindingsGenerateReportCreateRequest) (*ReportGenerate, *http.Response, error)

	/*
	FindingsList Method for FindingsList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFindingsListRequest
	*/
	FindingsList(ctx context.Context) ApiFindingsListRequest

	// FindingsListExecute executes the request
	//  @return PaginatedFindingList
	FindingsListExecute(r ApiFindingsListRequest) (*PaginatedFindingList, *http.Response, error)

	/*
	FindingsMetadataCreate Method for FindingsMetadataCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsMetadataCreateRequest
	*/
	FindingsMetadataCreate(ctx context.Context, id int32) ApiFindingsMetadataCreateRequest

	// FindingsMetadataCreateExecute executes the request
	//  @return FindingMeta
	FindingsMetadataCreateExecute(r ApiFindingsMetadataCreateRequest) (*FindingMeta, *http.Response, error)

	/*
	FindingsMetadataDestroy Method for FindingsMetadataDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsMetadataDestroyRequest
	*/
	FindingsMetadataDestroy(ctx context.Context, id int32) ApiFindingsMetadataDestroyRequest

	// FindingsMetadataDestroyExecute executes the request
	FindingsMetadataDestroyExecute(r ApiFindingsMetadataDestroyRequest) (*http.Response, error)

	/*
	FindingsMetadataList Method for FindingsMetadataList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsMetadataListRequest
	*/
	FindingsMetadataList(ctx context.Context, id int32) ApiFindingsMetadataListRequest

	// FindingsMetadataListExecute executes the request
	//  @return []FindingMeta
	FindingsMetadataListExecute(r ApiFindingsMetadataListRequest) ([]FindingMeta, *http.Response, error)

	/*
	FindingsMetadataUpdate Method for FindingsMetadataUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsMetadataUpdateRequest
	*/
	FindingsMetadataUpdate(ctx context.Context, id int32) ApiFindingsMetadataUpdateRequest

	// FindingsMetadataUpdateExecute executes the request
	//  @return FindingMeta
	FindingsMetadataUpdateExecute(r ApiFindingsMetadataUpdateRequest) (*FindingMeta, *http.Response, error)

	/*
	FindingsNotesCreate Method for FindingsNotesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsNotesCreateRequest
	*/
	FindingsNotesCreate(ctx context.Context, id int32) ApiFindingsNotesCreateRequest

	// FindingsNotesCreateExecute executes the request
	//  @return Note
	FindingsNotesCreateExecute(r ApiFindingsNotesCreateRequest) (*Note, *http.Response, error)

	/*
	FindingsNotesRetrieve Method for FindingsNotesRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsNotesRetrieveRequest
	*/
	FindingsNotesRetrieve(ctx context.Context, id int32) ApiFindingsNotesRetrieveRequest

	// FindingsNotesRetrieveExecute executes the request
	//  @return FindingToNotes
	FindingsNotesRetrieveExecute(r ApiFindingsNotesRetrieveRequest) (*FindingToNotes, *http.Response, error)

	/*
	FindingsOriginalCreate Method for FindingsOriginalCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@param newFid
	@return ApiFindingsOriginalCreateRequest
	*/
	FindingsOriginalCreate(ctx context.Context, id int32, newFid int32) ApiFindingsOriginalCreateRequest

	// FindingsOriginalCreateExecute executes the request
	FindingsOriginalCreateExecute(r ApiFindingsOriginalCreateRequest) (*http.Response, error)

	/*
	FindingsPartialUpdate Method for FindingsPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsPartialUpdateRequest
	*/
	FindingsPartialUpdate(ctx context.Context, id int32) ApiFindingsPartialUpdateRequest

	// FindingsPartialUpdateExecute executes the request
	//  @return Finding
	FindingsPartialUpdateExecute(r ApiFindingsPartialUpdateRequest) (*Finding, *http.Response, error)

	/*
	FindingsRemoveNotePartialUpdate Method for FindingsRemoveNotePartialUpdate

	Remove Note From Finding Note

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsRemoveNotePartialUpdateRequest
	*/
	FindingsRemoveNotePartialUpdate(ctx context.Context, id int32) ApiFindingsRemoveNotePartialUpdateRequest

	// FindingsRemoveNotePartialUpdateExecute executes the request
	FindingsRemoveNotePartialUpdateExecute(r ApiFindingsRemoveNotePartialUpdateRequest) (*http.Response, error)

	/*
	FindingsRemoveTagsPartialUpdate Method for FindingsRemoveTagsPartialUpdate

	Remove Tag(s) from finding list of tags

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsRemoveTagsPartialUpdateRequest
	*/
	FindingsRemoveTagsPartialUpdate(ctx context.Context, id int32) ApiFindingsRemoveTagsPartialUpdateRequest

	// FindingsRemoveTagsPartialUpdateExecute executes the request
	FindingsRemoveTagsPartialUpdateExecute(r ApiFindingsRemoveTagsPartialUpdateRequest) (*http.Response, error)

	/*
	FindingsRemoveTagsUpdate Method for FindingsRemoveTagsUpdate

	Remove Tag(s) from finding list of tags

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsRemoveTagsUpdateRequest
	*/
	FindingsRemoveTagsUpdate(ctx context.Context, id int32) ApiFindingsRemoveTagsUpdateRequest

	// FindingsRemoveTagsUpdateExecute executes the request
	FindingsRemoveTagsUpdateExecute(r ApiFindingsRemoveTagsUpdateRequest) (*http.Response, error)

	/*
	FindingsRequestResponseCreate Method for FindingsRequestResponseCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsRequestResponseCreateRequest
	*/
	FindingsRequestResponseCreate(ctx context.Context, id int32) ApiFindingsRequestResponseCreateRequest

	// FindingsRequestResponseCreateExecute executes the request
	//  @return BurpRawRequestResponse
	FindingsRequestResponseCreateExecute(r ApiFindingsRequestResponseCreateRequest) (*BurpRawRequestResponse, *http.Response, error)

	/*
	FindingsRequestResponseRetrieve Method for FindingsRequestResponseRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsRequestResponseRetrieveRequest
	*/
	FindingsRequestResponseRetrieve(ctx context.Context, id int32) ApiFindingsRequestResponseRetrieveRequest

	// FindingsRequestResponseRetrieveExecute executes the request
	//  @return BurpRawRequestResponse
	FindingsRequestResponseRetrieveExecute(r ApiFindingsRequestResponseRetrieveRequest) (*BurpRawRequestResponse, *http.Response, error)

	/*
	FindingsRetrieve Method for FindingsRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsRetrieveRequest
	*/
	FindingsRetrieve(ctx context.Context, id int32) ApiFindingsRetrieveRequest

	// FindingsRetrieveExecute executes the request
	//  @return Finding
	FindingsRetrieveExecute(r ApiFindingsRetrieveRequest) (*Finding, *http.Response, error)

	/*
	FindingsTagsCreate Method for FindingsTagsCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsTagsCreateRequest
	*/
	FindingsTagsCreate(ctx context.Context, id int32) ApiFindingsTagsCreateRequest

	// FindingsTagsCreateExecute executes the request
	//  @return Tag
	FindingsTagsCreateExecute(r ApiFindingsTagsCreateRequest) (*Tag, *http.Response, error)

	/*
	FindingsTagsRetrieve Method for FindingsTagsRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsTagsRetrieveRequest
	*/
	FindingsTagsRetrieve(ctx context.Context, id int32) ApiFindingsTagsRetrieveRequest

	// FindingsTagsRetrieveExecute executes the request
	//  @return Tag
	FindingsTagsRetrieveExecute(r ApiFindingsTagsRetrieveRequest) (*Tag, *http.Response, error)

	/*
	FindingsUpdate Method for FindingsUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this finding.
	@return ApiFindingsUpdateRequest
	*/
	FindingsUpdate(ctx context.Context, id int32) ApiFindingsUpdateRequest

	// FindingsUpdateExecute executes the request
	//  @return Finding
	FindingsUpdateExecute(r ApiFindingsUpdateRequest) (*Finding, *http.Response, error)
}

// FindingsAPIService FindingsAPI service
type FindingsAPIService service

type ApiFindingsAcceptRisksCreateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	acceptedRiskRequest *[]AcceptedRiskRequest
	active *bool
	componentName *string
	componentVersion *string
	created *time.Time
	cvssv3 *string
	cvssv3Score *float32
	cwe *[]int32
	date *string
	defectReviewRequestedBy *[]int32
	description *string
	discoveredAfter *string
	discoveredBefore *string
	discoveredOn *string
	duplicate *bool
	duplicateFinding *int32
	dynamicFinding *bool
	effortForFixing *string
	endpoints *[]int32
	epssPercentile *float32
	epssScore *float32
	falseP *bool
	filePath *string
	findingGroup *[]float32
	foundBy *[]int32
	hasJira *bool
	hasTags *bool
	hashCode *string
	id *[]int32
	impact *string
	inheritedTags *[][]int32
	isMitigated *bool
	jiraChange *time.Time
	jiraCreation *time.Time
	lastReviewed *time.Time
	lastReviewedBy *[]int32
	lastStatusUpdate *time.Time
	limit *int32
	mitigated *time.Time
	mitigatedAfter *string
	mitigatedBefore *string
	mitigatedBy *[]int32
	mitigatedOn *string
	mitigation *string
	nbOccurences *[]int32
	notTag *string
	notTags *[]string
	notTestEngagementProductTags *[]string
	notTestEngagementTags *[]string
	notTestTags *[]string
	numericalSeverity *string
	o *[]string
	offset *int32
	outOfScope *bool
	outsideOfSla *float32
	param *string
	payload *string
	plannedRemediationDate *string
	plannedRemediationVersion *string
	productLifecycle *string
	productName *string
	productNameContains *string
	publishDate *string
	references *string
	reporter *[]int32
	reviewRequestedBy *[]int32
	reviewers *[]int32
	riskAcceptance *float32
	riskAccepted *bool
	sastSinkObject *string
	sastSourceFilePath *string
	sastSourceLine *[]int32
	sastSourceObject *string
	scannerConfidence *[]int32
	service *string
	severity *string
	severityJustification *string
	slaExpirationDate *string
	slaStartDate *string
	sonarqubeIssue *[]int32
	staticFinding *bool
	stepsToReproduce *string
	tag *string
	tags *[]string
	test *int32
	testEngagement *[]int32
	testEngagementProduct *[]int32
	testEngagementProductProdType *[]int32
	testEngagementProductTags *[]string
	testEngagementTags *[]string
	testTags *[]string
	testTestType *[]int32
	title *string
	underDefectReview *bool
	underReview *bool
	uniqueIdFromTool *string
	verified *bool
	vulnIdFromTool *string
	vulnerabilityId *string
}

func (r ApiFindingsAcceptRisksCreateRequest) AcceptedRiskRequest(acceptedRiskRequest []AcceptedRiskRequest) ApiFindingsAcceptRisksCreateRequest {
	r.acceptedRiskRequest = &acceptedRiskRequest
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Active(active bool) ApiFindingsAcceptRisksCreateRequest {
	r.active = &active
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) ComponentName(componentName string) ApiFindingsAcceptRisksCreateRequest {
	r.componentName = &componentName
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) ComponentVersion(componentVersion string) ApiFindingsAcceptRisksCreateRequest {
	r.componentVersion = &componentVersion
	return r
}

// The date the finding was created inside DefectDojo.  * &#x60;None&#x60; - Any date * &#x60;1&#x60; - Today * &#x60;2&#x60; - Past 7 days * &#x60;3&#x60; - Past 30 days * &#x60;4&#x60; - Past 90 days * &#x60;5&#x60; - Current month * &#x60;6&#x60; - Current year * &#x60;7&#x60; - Past year
func (r ApiFindingsAcceptRisksCreateRequest) Created(created time.Time) ApiFindingsAcceptRisksCreateRequest {
	r.created = &created
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Cvssv3(cvssv3 string) ApiFindingsAcceptRisksCreateRequest {
	r.cvssv3 = &cvssv3
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Cvssv3Score(cvssv3Score float32) ApiFindingsAcceptRisksCreateRequest {
	r.cvssv3Score = &cvssv3Score
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) Cwe(cwe []int32) ApiFindingsAcceptRisksCreateRequest {
	r.cwe = &cwe
	return r
}

// The date the flaw was discovered.  * &#x60;None&#x60; - Any date * &#x60;1&#x60; - Today * &#x60;2&#x60; - Past 7 days * &#x60;3&#x60; - Past 30 days * &#x60;4&#x60; - Past 90 days * &#x60;5&#x60; - Current month * &#x60;6&#x60; - Current year * &#x60;7&#x60; - Past year
func (r ApiFindingsAcceptRisksCreateRequest) Date(date string) ApiFindingsAcceptRisksCreateRequest {
	r.date = &date
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) DefectReviewRequestedBy(defectReviewRequestedBy []int32) ApiFindingsAcceptRisksCreateRequest {
	r.defectReviewRequestedBy = &defectReviewRequestedBy
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Description(description string) ApiFindingsAcceptRisksCreateRequest {
	r.description = &description
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) DiscoveredAfter(discoveredAfter string) ApiFindingsAcceptRisksCreateRequest {
	r.discoveredAfter = &discoveredAfter
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) DiscoveredBefore(discoveredBefore string) ApiFindingsAcceptRisksCreateRequest {
	r.discoveredBefore = &discoveredBefore
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) DiscoveredOn(discoveredOn string) ApiFindingsAcceptRisksCreateRequest {
	r.discoveredOn = &discoveredOn
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Duplicate(duplicate bool) ApiFindingsAcceptRisksCreateRequest {
	r.duplicate = &duplicate
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) DuplicateFinding(duplicateFinding int32) ApiFindingsAcceptRisksCreateRequest {
	r.duplicateFinding = &duplicateFinding
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) DynamicFinding(dynamicFinding bool) ApiFindingsAcceptRisksCreateRequest {
	r.dynamicFinding = &dynamicFinding
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) EffortForFixing(effortForFixing string) ApiFindingsAcceptRisksCreateRequest {
	r.effortForFixing = &effortForFixing
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) Endpoints(endpoints []int32) ApiFindingsAcceptRisksCreateRequest {
	r.endpoints = &endpoints
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) EpssPercentile(epssPercentile float32) ApiFindingsAcceptRisksCreateRequest {
	r.epssPercentile = &epssPercentile
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) EpssScore(epssScore float32) ApiFindingsAcceptRisksCreateRequest {
	r.epssScore = &epssScore
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) FalseP(falseP bool) ApiFindingsAcceptRisksCreateRequest {
	r.falseP = &falseP
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) FilePath(filePath string) ApiFindingsAcceptRisksCreateRequest {
	r.filePath = &filePath
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) FindingGroup(findingGroup []float32) ApiFindingsAcceptRisksCreateRequest {
	r.findingGroup = &findingGroup
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) FoundBy(foundBy []int32) ApiFindingsAcceptRisksCreateRequest {
	r.foundBy = &foundBy
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) HasJira(hasJira bool) ApiFindingsAcceptRisksCreateRequest {
	r.hasJira = &hasJira
	return r
}

// Has tags
func (r ApiFindingsAcceptRisksCreateRequest) HasTags(hasTags bool) ApiFindingsAcceptRisksCreateRequest {
	r.hasTags = &hasTags
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) HashCode(hashCode string) ApiFindingsAcceptRisksCreateRequest {
	r.hashCode = &hashCode
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) Id(id []int32) ApiFindingsAcceptRisksCreateRequest {
	r.id = &id
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Impact(impact string) ApiFindingsAcceptRisksCreateRequest {
	r.impact = &impact
	return r
}

// Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field
func (r ApiFindingsAcceptRisksCreateRequest) InheritedTags(inheritedTags [][]int32) ApiFindingsAcceptRisksCreateRequest {
	r.inheritedTags = &inheritedTags
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) IsMitigated(isMitigated bool) ApiFindingsAcceptRisksCreateRequest {
	r.isMitigated = &isMitigated
	return r
}

// The date the linked Jira issue was last modified.  * &#x60;None&#x60; - Any date * &#x60;1&#x60; - Today * &#x60;2&#x60; - Past 7 days * &#x60;3&#x60; - Past 30 days * &#x60;4&#x60; - Past 90 days * &#x60;5&#x60; - Current month * &#x60;6&#x60; - Current year * &#x60;7&#x60; - Past year
func (r ApiFindingsAcceptRisksCreateRequest) JiraChange(jiraChange time.Time) ApiFindingsAcceptRisksCreateRequest {
	r.jiraChange = &jiraChange
	return r
}

// The date a Jira issue was created from this finding.  * &#x60;None&#x60; - Any date * &#x60;1&#x60; - Today * &#x60;2&#x60; - Past 7 days * &#x60;3&#x60; - Past 30 days * &#x60;4&#x60; - Past 90 days * &#x60;5&#x60; - Current month * &#x60;6&#x60; - Current year * &#x60;7&#x60; - Past year
func (r ApiFindingsAcceptRisksCreateRequest) JiraCreation(jiraCreation time.Time) ApiFindingsAcceptRisksCreateRequest {
	r.jiraCreation = &jiraCreation
	return r
}

// Provides the date the flaw was last &#39;touched&#39; by a tester.  * &#x60;None&#x60; - Any date * &#x60;1&#x60; - Today * &#x60;2&#x60; - Past 7 days * &#x60;3&#x60; - Past 30 days * &#x60;4&#x60; - Past 90 days * &#x60;5&#x60; - Current month * &#x60;6&#x60; - Current year * &#x60;7&#x60; - Past year
func (r ApiFindingsAcceptRisksCreateRequest) LastReviewed(lastReviewed time.Time) ApiFindingsAcceptRisksCreateRequest {
	r.lastReviewed = &lastReviewed
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) LastReviewedBy(lastReviewedBy []int32) ApiFindingsAcceptRisksCreateRequest {
	r.lastReviewedBy = &lastReviewedBy
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) LastStatusUpdate(lastStatusUpdate time.Time) ApiFindingsAcceptRisksCreateRequest {
	r.lastStatusUpdate = &lastStatusUpdate
	return r
}

// Number of results to return per page.
func (r ApiFindingsAcceptRisksCreateRequest) Limit(limit int32) ApiFindingsAcceptRisksCreateRequest {
	r.limit = &limit
	return r
}

// Denotes if this flaw has been fixed by storing the date it was fixed.  * &#x60;None&#x60; - Any date * &#x60;1&#x60; - Today * &#x60;2&#x60; - Past 7 days * &#x60;3&#x60; - Past 30 days * &#x60;4&#x60; - Past 90 days * &#x60;5&#x60; - Current month * &#x60;6&#x60; - Current year * &#x60;7&#x60; - Past year
func (r ApiFindingsAcceptRisksCreateRequest) Mitigated(mitigated time.Time) ApiFindingsAcceptRisksCreateRequest {
	r.mitigated = &mitigated
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) MitigatedAfter(mitigatedAfter string) ApiFindingsAcceptRisksCreateRequest {
	r.mitigatedAfter = &mitigatedAfter
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) MitigatedBefore(mitigatedBefore string) ApiFindingsAcceptRisksCreateRequest {
	r.mitigatedBefore = &mitigatedBefore
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) MitigatedBy(mitigatedBy []int32) ApiFindingsAcceptRisksCreateRequest {
	r.mitigatedBy = &mitigatedBy
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) MitigatedOn(mitigatedOn string) ApiFindingsAcceptRisksCreateRequest {
	r.mitigatedOn = &mitigatedOn
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Mitigation(mitigation string) ApiFindingsAcceptRisksCreateRequest {
	r.mitigation = &mitigation
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) NbOccurences(nbOccurences []int32) ApiFindingsAcceptRisksCreateRequest {
	r.nbOccurences = &nbOccurences
	return r
}

// Not Tag name contains
func (r ApiFindingsAcceptRisksCreateRequest) NotTag(notTag string) ApiFindingsAcceptRisksCreateRequest {
	r.notTag = &notTag
	return r
}

// Comma separated list of exact tags not present on model
func (r ApiFindingsAcceptRisksCreateRequest) NotTags(notTags []string) ApiFindingsAcceptRisksCreateRequest {
	r.notTags = &notTags
	return r
}

// Comma separated list of exact tags not present on product
func (r ApiFindingsAcceptRisksCreateRequest) NotTestEngagementProductTags(notTestEngagementProductTags []string) ApiFindingsAcceptRisksCreateRequest {
	r.notTestEngagementProductTags = &notTestEngagementProductTags
	return r
}

// Comma separated list of exact tags not present on engagement
func (r ApiFindingsAcceptRisksCreateRequest) NotTestEngagementTags(notTestEngagementTags []string) ApiFindingsAcceptRisksCreateRequest {
	r.notTestEngagementTags = &notTestEngagementTags
	return r
}

// Comma separated list of exact tags present on test
func (r ApiFindingsAcceptRisksCreateRequest) NotTestTags(notTestTags []string) ApiFindingsAcceptRisksCreateRequest {
	r.notTestTags = &notTestTags
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) NumericalSeverity(numericalSeverity string) ApiFindingsAcceptRisksCreateRequest {
	r.numericalSeverity = &numericalSeverity
	return r
}

// Ordering  * &#x60;active&#x60; - Active * &#x60;-active&#x60; - Active (descending) * &#x60;component_name&#x60; - Component name * &#x60;-component_name&#x60; - Component name (descending) * &#x60;component_version&#x60; - Component version * &#x60;-component_version&#x60; - Component version (descending) * &#x60;created&#x60; - Created * &#x60;-created&#x60; - Created (descending) * &#x60;last_status_update&#x60; - Last status update * &#x60;-last_status_update&#x60; - Last status update (descending) * &#x60;last_reviewed&#x60; - Last reviewed * &#x60;-last_reviewed&#x60; - Last reviewed (descending) * &#x60;cwe&#x60; - Cwe * &#x60;-cwe&#x60; - Cwe (descending) * &#x60;date&#x60; - Date * &#x60;-date&#x60; - Date (descending) * &#x60;duplicate&#x60; - Duplicate * &#x60;-duplicate&#x60; - Duplicate (descending) * &#x60;dynamic_finding&#x60; - Dynamic finding * &#x60;-dynamic_finding&#x60; - Dynamic finding (descending) * &#x60;false_p&#x60; - False p * &#x60;-false_p&#x60; - False p (descending) * &#x60;found_by&#x60; - Found by * &#x60;-found_by&#x60; - Found by (descending) * &#x60;id&#x60; - Id * &#x60;-id&#x60; - Id (descending) * &#x60;is_mitigated&#x60; - Is mitigated * &#x60;-is_mitigated&#x60; - Is mitigated (descending) * &#x60;numerical_severity&#x60; - Numerical severity * &#x60;-numerical_severity&#x60; - Numerical severity (descending) * &#x60;out_of_scope&#x60; - Out of scope * &#x60;-out_of_scope&#x60; - Out of scope (descending) * &#x60;severity&#x60; - Severity * &#x60;-severity&#x60; - Severity (descending) * &#x60;reviewers&#x60; - Reviewers * &#x60;-reviewers&#x60; - Reviewers (descending) * &#x60;static_finding&#x60; - Static finding * &#x60;-static_finding&#x60; - Static finding (descending) * &#x60;test__engagement__product__name&#x60; - Test  engagement  product  name * &#x60;-test__engagement__product__name&#x60; - Test  engagement  product  name (descending) * &#x60;title&#x60; - Title * &#x60;-title&#x60; - Title (descending) * &#x60;under_defect_review&#x60; - Under defect review * &#x60;-under_defect_review&#x60; - Under defect review (descending) * &#x60;under_review&#x60; - Under review * &#x60;-under_review&#x60; - Under review (descending) * &#x60;verified&#x60; - Verified * &#x60;-verified&#x60; - Verified (descending)
func (r ApiFindingsAcceptRisksCreateRequest) O(o []string) ApiFindingsAcceptRisksCreateRequest {
	r.o = &o
	return r
}

// The initial index from which to return the results.
func (r ApiFindingsAcceptRisksCreateRequest) Offset(offset int32) ApiFindingsAcceptRisksCreateRequest {
	r.offset = &offset
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) OutOfScope(outOfScope bool) ApiFindingsAcceptRisksCreateRequest {
	r.outOfScope = &outOfScope
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) OutsideOfSla(outsideOfSla float32) ApiFindingsAcceptRisksCreateRequest {
	r.outsideOfSla = &outsideOfSla
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Param(param string) ApiFindingsAcceptRisksCreateRequest {
	r.param = &param
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Payload(payload string) ApiFindingsAcceptRisksCreateRequest {
	r.payload = &payload
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) PlannedRemediationDate(plannedRemediationDate string) ApiFindingsAcceptRisksCreateRequest {
	r.plannedRemediationDate = &plannedRemediationDate
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) PlannedRemediationVersion(plannedRemediationVersion string) ApiFindingsAcceptRisksCreateRequest {
	r.plannedRemediationVersion = &plannedRemediationVersion
	return r
}

// Comma separated list of exact product lifecycles
func (r ApiFindingsAcceptRisksCreateRequest) ProductLifecycle(productLifecycle string) ApiFindingsAcceptRisksCreateRequest {
	r.productLifecycle = &productLifecycle
	return r
}

// exact product name
func (r ApiFindingsAcceptRisksCreateRequest) ProductName(productName string) ApiFindingsAcceptRisksCreateRequest {
	r.productName = &productName
	return r
}

// exact product name
func (r ApiFindingsAcceptRisksCreateRequest) ProductNameContains(productNameContains string) ApiFindingsAcceptRisksCreateRequest {
	r.productNameContains = &productNameContains
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) PublishDate(publishDate string) ApiFindingsAcceptRisksCreateRequest {
	r.publishDate = &publishDate
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) References(references string) ApiFindingsAcceptRisksCreateRequest {
	r.references = &references
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) Reporter(reporter []int32) ApiFindingsAcceptRisksCreateRequest {
	r.reporter = &reporter
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) ReviewRequestedBy(reviewRequestedBy []int32) ApiFindingsAcceptRisksCreateRequest {
	r.reviewRequestedBy = &reviewRequestedBy
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) Reviewers(reviewers []int32) ApiFindingsAcceptRisksCreateRequest {
	r.reviewers = &reviewers
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) RiskAcceptance(riskAcceptance float32) ApiFindingsAcceptRisksCreateRequest {
	r.riskAcceptance = &riskAcceptance
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) RiskAccepted(riskAccepted bool) ApiFindingsAcceptRisksCreateRequest {
	r.riskAccepted = &riskAccepted
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) SastSinkObject(sastSinkObject string) ApiFindingsAcceptRisksCreateRequest {
	r.sastSinkObject = &sastSinkObject
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) SastSourceFilePath(sastSourceFilePath string) ApiFindingsAcceptRisksCreateRequest {
	r.sastSourceFilePath = &sastSourceFilePath
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) SastSourceLine(sastSourceLine []int32) ApiFindingsAcceptRisksCreateRequest {
	r.sastSourceLine = &sastSourceLine
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) SastSourceObject(sastSourceObject string) ApiFindingsAcceptRisksCreateRequest {
	r.sastSourceObject = &sastSourceObject
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) ScannerConfidence(scannerConfidence []int32) ApiFindingsAcceptRisksCreateRequest {
	r.scannerConfidence = &scannerConfidence
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Service(service string) ApiFindingsAcceptRisksCreateRequest {
	r.service = &service
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Severity(severity string) ApiFindingsAcceptRisksCreateRequest {
	r.severity = &severity
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) SeverityJustification(severityJustification string) ApiFindingsAcceptRisksCreateRequest {
	r.severityJustification = &severityJustification
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) SlaExpirationDate(slaExpirationDate string) ApiFindingsAcceptRisksCreateRequest {
	r.slaExpirationDate = &slaExpirationDate
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) SlaStartDate(slaStartDate string) ApiFindingsAcceptRisksCreateRequest {
	r.slaStartDate = &slaStartDate
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) SonarqubeIssue(sonarqubeIssue []int32) ApiFindingsAcceptRisksCreateRequest {
	r.sonarqubeIssue = &sonarqubeIssue
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) StaticFinding(staticFinding bool) ApiFindingsAcceptRisksCreateRequest {
	r.staticFinding = &staticFinding
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) StepsToReproduce(stepsToReproduce string) ApiFindingsAcceptRisksCreateRequest {
	r.stepsToReproduce = &stepsToReproduce
	return r
}

// Tag name contains
func (r ApiFindingsAcceptRisksCreateRequest) Tag(tag string) ApiFindingsAcceptRisksCreateRequest {
	r.tag = &tag
	return r
}

// Comma separated list of exact tags
func (r ApiFindingsAcceptRisksCreateRequest) Tags(tags []string) ApiFindingsAcceptRisksCreateRequest {
	r.tags = &tags
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Test(test int32) ApiFindingsAcceptRisksCreateRequest {
	r.test = &test
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) TestEngagement(testEngagement []int32) ApiFindingsAcceptRisksCreateRequest {
	r.testEngagement = &testEngagement
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) TestEngagementProduct(testEngagementProduct []int32) ApiFindingsAcceptRisksCreateRequest {
	r.testEngagementProduct = &testEngagementProduct
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) TestEngagementProductProdType(testEngagementProductProdType []int32) ApiFindingsAcceptRisksCreateRequest {
	r.testEngagementProductProdType = &testEngagementProductProdType
	return r
}

// Comma separated list of exact tags present on product
func (r ApiFindingsAcceptRisksCreateRequest) TestEngagementProductTags(testEngagementProductTags []string) ApiFindingsAcceptRisksCreateRequest {
	r.testEngagementProductTags = &testEngagementProductTags
	return r
}

// Comma separated list of exact tags present on engagement
func (r ApiFindingsAcceptRisksCreateRequest) TestEngagementTags(testEngagementTags []string) ApiFindingsAcceptRisksCreateRequest {
	r.testEngagementTags = &testEngagementTags
	return r
}

// Comma separated list of exact tags present on test
func (r ApiFindingsAcceptRisksCreateRequest) TestTags(testTags []string) ApiFindingsAcceptRisksCreateRequest {
	r.testTags = &testTags
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsAcceptRisksCreateRequest) TestTestType(testTestType []int32) ApiFindingsAcceptRisksCreateRequest {
	r.testTestType = &testTestType
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Title(title string) ApiFindingsAcceptRisksCreateRequest {
	r.title = &title
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) UnderDefectReview(underDefectReview bool) ApiFindingsAcceptRisksCreateRequest {
	r.underDefectReview = &underDefectReview
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) UnderReview(underReview bool) ApiFindingsAcceptRisksCreateRequest {
	r.underReview = &underReview
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) UniqueIdFromTool(uniqueIdFromTool string) ApiFindingsAcceptRisksCreateRequest {
	r.uniqueIdFromTool = &uniqueIdFromTool
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Verified(verified bool) ApiFindingsAcceptRisksCreateRequest {
	r.verified = &verified
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) VulnIdFromTool(vulnIdFromTool string) ApiFindingsAcceptRisksCreateRequest {
	r.vulnIdFromTool = &vulnIdFromTool
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) VulnerabilityId(vulnerabilityId string) ApiFindingsAcceptRisksCreateRequest {
	r.vulnerabilityId = &vulnerabilityId
	return r
}

func (r ApiFindingsAcceptRisksCreateRequest) Execute() (*PaginatedRiskAcceptanceList, *http.Response, error) {
	return r.ApiService.FindingsAcceptRisksCreateExecute(r)
}

/*
FindingsAcceptRisksCreate Method for FindingsAcceptRisksCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindingsAcceptRisksCreateRequest
*/
func (a *FindingsAPIService) FindingsAcceptRisksCreate(ctx context.Context) ApiFindingsAcceptRisksCreateRequest {
	return ApiFindingsAcceptRisksCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedRiskAcceptanceList
func (a *FindingsAPIService) FindingsAcceptRisksCreateExecute(r ApiFindingsAcceptRisksCreateRequest) (*PaginatedRiskAcceptanceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedRiskAcceptanceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsAcceptRisksCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/accept_risks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.acceptedRiskRequest == nil {
		return localVarReturnValue, nil, reportError("acceptedRiskRequest is required and must be specified")
	}

	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.componentName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "component_name", r.componentName, "form", "")
	}
	if r.componentVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "component_version", r.componentVersion, "form", "")
	}
	if r.created != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created", r.created, "form", "")
	}
	if r.cvssv3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cvssv3", r.cvssv3, "form", "")
	}
	if r.cvssv3Score != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cvssv3_score", r.cvssv3Score, "form", "")
	}
	if r.cwe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cwe", r.cwe, "form", "csv")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.defectReviewRequestedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defect_review_requested_by", r.defectReviewRequestedBy, "form", "csv")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.discoveredAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discovered_after", r.discoveredAfter, "form", "")
	}
	if r.discoveredBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discovered_before", r.discoveredBefore, "form", "")
	}
	if r.discoveredOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discovered_on", r.discoveredOn, "form", "")
	}
	if r.duplicate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duplicate", r.duplicate, "form", "")
	}
	if r.duplicateFinding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duplicate_finding", r.duplicateFinding, "form", "")
	}
	if r.dynamicFinding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_finding", r.dynamicFinding, "form", "")
	}
	if r.effortForFixing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "effort_for_fixing", r.effortForFixing, "form", "")
	}
	if r.endpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endpoints", r.endpoints, "form", "csv")
	}
	if r.epssPercentile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "epss_percentile", r.epssPercentile, "form", "")
	}
	if r.epssScore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "epss_score", r.epssScore, "form", "")
	}
	if r.falseP != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "false_p", r.falseP, "form", "")
	}
	if r.filePath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "file_path", r.filePath, "form", "")
	}
	if r.findingGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finding_group", r.findingGroup, "form", "csv")
	}
	if r.foundBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "found_by", r.foundBy, "form", "csv")
	}
	if r.hasJira != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_jira", r.hasJira, "form", "")
	}
	if r.hasTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_tags", r.hasTags, "form", "")
	}
	if r.hashCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hash_code", r.hashCode, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "csv")
	}
	if r.impact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "impact", r.impact, "form", "")
	}
	if r.inheritedTags != nil {
		t := *r.inheritedTags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inherited_tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inherited_tags", t, "form", "multi")
		}
	}
	if r.isMitigated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_mitigated", r.isMitigated, "form", "")
	}
	if r.jiraChange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jira_change", r.jiraChange, "form", "")
	}
	if r.jiraCreation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jira_creation", r.jiraCreation, "form", "")
	}
	if r.lastReviewed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_reviewed", r.lastReviewed, "form", "")
	}
	if r.lastReviewedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_reviewed_by", r.lastReviewedBy, "form", "csv")
	}
	if r.lastStatusUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_status_update", r.lastStatusUpdate, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.mitigated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitigated", r.mitigated, "form", "")
	}
	if r.mitigatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitigated_after", r.mitigatedAfter, "form", "")
	}
	if r.mitigatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitigated_before", r.mitigatedBefore, "form", "")
	}
	if r.mitigatedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitigated_by", r.mitigatedBy, "form", "csv")
	}
	if r.mitigatedOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitigated_on", r.mitigatedOn, "form", "")
	}
	if r.mitigation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitigation", r.mitigation, "form", "")
	}
	if r.nbOccurences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nb_occurences", r.nbOccurences, "form", "csv")
	}
	if r.notTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_tag", r.notTag, "form", "")
	}
	if r.notTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_tags", r.notTags, "form", "csv")
	}
	if r.notTestEngagementProductTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_test__engagement__product__tags", r.notTestEngagementProductTags, "form", "csv")
	}
	if r.notTestEngagementTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_test__engagement__tags", r.notTestEngagementTags, "form", "csv")
	}
	if r.notTestTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_test__tags", r.notTestTags, "form", "csv")
	}
	if r.numericalSeverity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numerical_severity", r.numericalSeverity, "form", "")
	}
	if r.o != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "o", r.o, "form", "csv")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.outOfScope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "out_of_scope", r.outOfScope, "form", "")
	}
	if r.outsideOfSla != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outside_of_sla", r.outsideOfSla, "form", "")
	}
	if r.param != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "param", r.param, "form", "")
	}
	if r.payload != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payload", r.payload, "form", "")
	}
	if r.plannedRemediationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "planned_remediation_date", r.plannedRemediationDate, "form", "")
	}
	if r.plannedRemediationVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "planned_remediation_version", r.plannedRemediationVersion, "form", "")
	}
	if r.productLifecycle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_lifecycle", r.productLifecycle, "form", "")
	}
	if r.productName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_name", r.productName, "form", "")
	}
	if r.productNameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_name_contains", r.productNameContains, "form", "")
	}
	if r.publishDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publish_date", r.publishDate, "form", "")
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "form", "")
	}
	if r.reporter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reporter", r.reporter, "form", "csv")
	}
	if r.reviewRequestedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "review_requested_by", r.reviewRequestedBy, "form", "csv")
	}
	if r.reviewers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reviewers", r.reviewers, "form", "csv")
	}
	if r.riskAcceptance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "risk_acceptance", r.riskAcceptance, "form", "")
	}
	if r.riskAccepted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "risk_accepted", r.riskAccepted, "form", "")
	}
	if r.sastSinkObject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sast_sink_object", r.sastSinkObject, "form", "")
	}
	if r.sastSourceFilePath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sast_source_file_path", r.sastSourceFilePath, "form", "")
	}
	if r.sastSourceLine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sast_source_line", r.sastSourceLine, "form", "csv")
	}
	if r.sastSourceObject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sast_source_object", r.sastSourceObject, "form", "")
	}
	if r.scannerConfidence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scanner_confidence", r.scannerConfidence, "form", "csv")
	}
	if r.service != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service", r.service, "form", "")
	}
	if r.severity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "severity", r.severity, "form", "")
	}
	if r.severityJustification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "severity_justification", r.severityJustification, "form", "")
	}
	if r.slaExpirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sla_expiration_date", r.slaExpirationDate, "form", "")
	}
	if r.slaStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sla_start_date", r.slaStartDate, "form", "")
	}
	if r.sonarqubeIssue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sonarqube_issue", r.sonarqubeIssue, "form", "csv")
	}
	if r.staticFinding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static_finding", r.staticFinding, "form", "")
	}
	if r.stepsToReproduce != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "steps_to_reproduce", r.stepsToReproduce, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "csv")
	}
	if r.test != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test", r.test, "form", "")
	}
	if r.testEngagement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test__engagement", r.testEngagement, "form", "csv")
	}
	if r.testEngagementProduct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test__engagement__product", r.testEngagementProduct, "form", "csv")
	}
	if r.testEngagementProductProdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test__engagement__product__prod_type", r.testEngagementProductProdType, "form", "csv")
	}
	if r.testEngagementProductTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test__engagement__product__tags", r.testEngagementProductTags, "form", "csv")
	}
	if r.testEngagementTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test__engagement__tags", r.testEngagementTags, "form", "csv")
	}
	if r.testTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test__tags", r.testTags, "form", "csv")
	}
	if r.testTestType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test__test_type", r.testTestType, "form", "csv")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.underDefectReview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "under_defect_review", r.underDefectReview, "form", "")
	}
	if r.underReview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "under_review", r.underReview, "form", "")
	}
	if r.uniqueIdFromTool != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unique_id_from_tool", r.uniqueIdFromTool, "form", "")
	}
	if r.verified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verified", r.verified, "form", "")
	}
	if r.vulnIdFromTool != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vuln_id_from_tool", r.vulnIdFromTool, "form", "")
	}
	if r.vulnerabilityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vulnerability_id", r.vulnerabilityId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.acceptedRiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsCloseCreateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	findingCloseRequest *FindingCloseRequest
}

func (r ApiFindingsCloseCreateRequest) FindingCloseRequest(findingCloseRequest FindingCloseRequest) ApiFindingsCloseCreateRequest {
	r.findingCloseRequest = &findingCloseRequest
	return r
}

func (r ApiFindingsCloseCreateRequest) Execute() (*FindingClose, *http.Response, error) {
	return r.ApiService.FindingsCloseCreateExecute(r)
}

/*
FindingsCloseCreate Method for FindingsCloseCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsCloseCreateRequest
*/
func (a *FindingsAPIService) FindingsCloseCreate(ctx context.Context, id int32) ApiFindingsCloseCreateRequest {
	return ApiFindingsCloseCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FindingClose
func (a *FindingsAPIService) FindingsCloseCreateExecute(r ApiFindingsCloseCreateRequest) (*FindingClose, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindingClose
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsCloseCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/close/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.findingCloseRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsCreateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	findingCreateRequest *FindingCreateRequest
}

func (r ApiFindingsCreateRequest) FindingCreateRequest(findingCreateRequest FindingCreateRequest) ApiFindingsCreateRequest {
	r.findingCreateRequest = &findingCreateRequest
	return r
}

func (r ApiFindingsCreateRequest) Execute() (*FindingCreate, *http.Response, error) {
	return r.ApiService.FindingsCreateExecute(r)
}

/*
FindingsCreate Method for FindingsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindingsCreateRequest
*/
func (a *FindingsAPIService) FindingsCreate(ctx context.Context) ApiFindingsCreateRequest {
	return ApiFindingsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FindingCreate
func (a *FindingsAPIService) FindingsCreateExecute(r ApiFindingsCreateRequest) (*FindingCreate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindingCreate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.findingCreateRequest == nil {
		return localVarReturnValue, nil, reportError("findingCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.findingCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsDeletePreviewListRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiFindingsDeletePreviewListRequest) Limit(limit int32) ApiFindingsDeletePreviewListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiFindingsDeletePreviewListRequest) Offset(offset int32) ApiFindingsDeletePreviewListRequest {
	r.offset = &offset
	return r
}

func (r ApiFindingsDeletePreviewListRequest) Execute() (*PaginatedDeletePreviewList, *http.Response, error) {
	return r.ApiService.FindingsDeletePreviewListExecute(r)
}

/*
FindingsDeletePreviewList Method for FindingsDeletePreviewList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsDeletePreviewListRequest
*/
func (a *FindingsAPIService) FindingsDeletePreviewList(ctx context.Context, id int32) ApiFindingsDeletePreviewListRequest {
	return ApiFindingsDeletePreviewListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedDeletePreviewList
func (a *FindingsAPIService) FindingsDeletePreviewListExecute(r ApiFindingsDeletePreviewListRequest) (*PaginatedDeletePreviewList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeletePreviewList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsDeletePreviewList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/delete_preview/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsDestroyRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
}

func (r ApiFindingsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.FindingsDestroyExecute(r)
}

/*
FindingsDestroy Method for FindingsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsDestroyRequest
*/
func (a *FindingsAPIService) FindingsDestroy(ctx context.Context, id int32) ApiFindingsDestroyRequest {
	return ApiFindingsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FindingsAPIService) FindingsDestroyExecute(r ApiFindingsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFindingsDuplicateListRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
}

func (r ApiFindingsDuplicateListRequest) Execute() ([]Finding, *http.Response, error) {
	return r.ApiService.FindingsDuplicateListExecute(r)
}

/*
FindingsDuplicateList Method for FindingsDuplicateList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsDuplicateListRequest
*/
func (a *FindingsAPIService) FindingsDuplicateList(ctx context.Context, id int32) ApiFindingsDuplicateListRequest {
	return ApiFindingsDuplicateListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []Finding
func (a *FindingsAPIService) FindingsDuplicateListExecute(r ApiFindingsDuplicateListRequest) ([]Finding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Finding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsDuplicateList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/duplicate/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsDuplicateResetCreateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
}

func (r ApiFindingsDuplicateResetCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.FindingsDuplicateResetCreateExecute(r)
}

/*
FindingsDuplicateResetCreate Method for FindingsDuplicateResetCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsDuplicateResetCreateRequest
*/
func (a *FindingsAPIService) FindingsDuplicateResetCreate(ctx context.Context, id int32) ApiFindingsDuplicateResetCreateRequest {
	return ApiFindingsDuplicateResetCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FindingsAPIService) FindingsDuplicateResetCreateExecute(r ApiFindingsDuplicateResetCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsDuplicateResetCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/duplicate/reset/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFindingsFilesCreateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	title *string
	file *os.File
}

func (r ApiFindingsFilesCreateRequest) Title(title string) ApiFindingsFilesCreateRequest {
	r.title = &title
	return r
}

func (r ApiFindingsFilesCreateRequest) File(file *os.File) ApiFindingsFilesCreateRequest {
	r.file = file
	return r
}

func (r ApiFindingsFilesCreateRequest) Execute() (*File, *http.Response, error) {
	return r.ApiService.FindingsFilesCreateExecute(r)
}

/*
FindingsFilesCreate Method for FindingsFilesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsFilesCreateRequest
*/
func (a *FindingsAPIService) FindingsFilesCreate(ctx context.Context, id int32) ApiFindingsFilesCreateRequest {
	return ApiFindingsFilesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return File
func (a *FindingsAPIService) FindingsFilesCreateExecute(r ApiFindingsFilesCreateRequest) (*File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsFilesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/files/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if strlen(*r.title) < 1 {
		return localVarReturnValue, nil, reportError("title must have at least 1 elements")
	}
	if strlen(*r.title) > 100 {
		return localVarReturnValue, nil, reportError("title must have less than 100 elements")
	}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsFilesDownloadRetrieveRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	fileId string
	id int32
}

func (r ApiFindingsFilesDownloadRetrieveRequest) Execute() (*RawFile, *http.Response, error) {
	return r.ApiService.FindingsFilesDownloadRetrieveExecute(r)
}

/*
FindingsFilesDownloadRetrieve Method for FindingsFilesDownloadRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileId
 @param id A unique integer value identifying this finding.
 @return ApiFindingsFilesDownloadRetrieveRequest
*/
func (a *FindingsAPIService) FindingsFilesDownloadRetrieve(ctx context.Context, fileId string, id int32) ApiFindingsFilesDownloadRetrieveRequest {
	return ApiFindingsFilesDownloadRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
		id: id,
	}
}

// Execute executes the request
//  @return RawFile
func (a *FindingsAPIService) FindingsFilesDownloadRetrieveExecute(r ApiFindingsFilesDownloadRetrieveRequest) (*RawFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RawFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsFilesDownloadRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/files/download/{file_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"file_id"+"}", url.PathEscape(parameterValueToString(r.fileId, "fileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsFilesRetrieveRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
}

func (r ApiFindingsFilesRetrieveRequest) Execute() (*FindingToFiles, *http.Response, error) {
	return r.ApiService.FindingsFilesRetrieveExecute(r)
}

/*
FindingsFilesRetrieve Method for FindingsFilesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsFilesRetrieveRequest
*/
func (a *FindingsAPIService) FindingsFilesRetrieve(ctx context.Context, id int32) ApiFindingsFilesRetrieveRequest {
	return ApiFindingsFilesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FindingToFiles
func (a *FindingsAPIService) FindingsFilesRetrieveExecute(r ApiFindingsFilesRetrieveRequest) (*FindingToFiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindingToFiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsFilesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/files/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsGenerateReportCreateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	reportGenerateOptionRequest *ReportGenerateOptionRequest
}

func (r ApiFindingsGenerateReportCreateRequest) ReportGenerateOptionRequest(reportGenerateOptionRequest ReportGenerateOptionRequest) ApiFindingsGenerateReportCreateRequest {
	r.reportGenerateOptionRequest = &reportGenerateOptionRequest
	return r
}

func (r ApiFindingsGenerateReportCreateRequest) Execute() (*ReportGenerate, *http.Response, error) {
	return r.ApiService.FindingsGenerateReportCreateExecute(r)
}

/*
FindingsGenerateReportCreate Method for FindingsGenerateReportCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindingsGenerateReportCreateRequest
*/
func (a *FindingsAPIService) FindingsGenerateReportCreate(ctx context.Context) ApiFindingsGenerateReportCreateRequest {
	return ApiFindingsGenerateReportCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReportGenerate
func (a *FindingsAPIService) FindingsGenerateReportCreateExecute(r ApiFindingsGenerateReportCreateRequest) (*ReportGenerate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportGenerate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsGenerateReportCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/generate_report/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reportGenerateOptionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsListRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	active *bool
	componentName *string
	componentVersion *string
	created *time.Time
	cvssv3 *string
	cvssv3Score *float32
	cwe *[]int32
	date *string
	defectReviewRequestedBy *[]int32
	description *string
	discoveredAfter *string
	discoveredBefore *string
	discoveredOn *string
	duplicate *bool
	duplicateFinding *int32
	dynamicFinding *bool
	effortForFixing *string
	endpoints *[]int32
	epssPercentile *float32
	epssScore *float32
	falseP *bool
	filePath *string
	findingGroup *[]float32
	foundBy *[]int32
	hasJira *bool
	hasTags *bool
	hashCode *string
	id *[]int32
	impact *string
	inheritedTags *[][]int32
	isMitigated *bool
	jiraChange *time.Time
	jiraCreation *time.Time
	lastReviewed *time.Time
	lastReviewedBy *[]int32
	lastStatusUpdate *time.Time
	limit *int32
	mitigated *time.Time
	mitigatedAfter *string
	mitigatedBefore *string
	mitigatedBy *[]int32
	mitigatedOn *string
	mitigation *string
	nbOccurences *[]int32
	notTag *string
	notTags *[]string
	notTestEngagementProductTags *[]string
	notTestEngagementTags *[]string
	notTestTags *[]string
	numericalSeverity *string
	o *[]string
	offset *int32
	outOfScope *bool
	outsideOfSla *float32
	param *string
	payload *string
	plannedRemediationDate *string
	plannedRemediationVersion *string
	prefetch *[]string
	productLifecycle *string
	productName *string
	productNameContains *string
	publishDate *string
	references *string
	relatedFields *bool
	reporter *[]int32
	reviewRequestedBy *[]int32
	reviewers *[]int32
	riskAcceptance *float32
	riskAccepted *bool
	sastSinkObject *string
	sastSourceFilePath *string
	sastSourceLine *[]int32
	sastSourceObject *string
	scannerConfidence *[]int32
	service *string
	severity *string
	severityJustification *string
	slaExpirationDate *string
	slaStartDate *string
	sonarqubeIssue *[]int32
	staticFinding *bool
	stepsToReproduce *string
	tag *string
	tags *[]string
	test *int32
	testEngagement *[]int32
	testEngagementProduct *[]int32
	testEngagementProductProdType *[]int32
	testEngagementProductTags *[]string
	testEngagementTags *[]string
	testTags *[]string
	testTestType *[]int32
	title *string
	underDefectReview *bool
	underReview *bool
	uniqueIdFromTool *string
	verified *bool
	vulnIdFromTool *string
	vulnerabilityId *string
}

func (r ApiFindingsListRequest) Active(active bool) ApiFindingsListRequest {
	r.active = &active
	return r
}

func (r ApiFindingsListRequest) ComponentName(componentName string) ApiFindingsListRequest {
	r.componentName = &componentName
	return r
}

func (r ApiFindingsListRequest) ComponentVersion(componentVersion string) ApiFindingsListRequest {
	r.componentVersion = &componentVersion
	return r
}

// The date the finding was created inside DefectDojo.  * &#x60;None&#x60; - Any date * &#x60;1&#x60; - Today * &#x60;2&#x60; - Past 7 days * &#x60;3&#x60; - Past 30 days * &#x60;4&#x60; - Past 90 days * &#x60;5&#x60; - Current month * &#x60;6&#x60; - Current year * &#x60;7&#x60; - Past year
func (r ApiFindingsListRequest) Created(created time.Time) ApiFindingsListRequest {
	r.created = &created
	return r
}

func (r ApiFindingsListRequest) Cvssv3(cvssv3 string) ApiFindingsListRequest {
	r.cvssv3 = &cvssv3
	return r
}

func (r ApiFindingsListRequest) Cvssv3Score(cvssv3Score float32) ApiFindingsListRequest {
	r.cvssv3Score = &cvssv3Score
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) Cwe(cwe []int32) ApiFindingsListRequest {
	r.cwe = &cwe
	return r
}

// The date the flaw was discovered.  * &#x60;None&#x60; - Any date * &#x60;1&#x60; - Today * &#x60;2&#x60; - Past 7 days * &#x60;3&#x60; - Past 30 days * &#x60;4&#x60; - Past 90 days * &#x60;5&#x60; - Current month * &#x60;6&#x60; - Current year * &#x60;7&#x60; - Past year
func (r ApiFindingsListRequest) Date(date string) ApiFindingsListRequest {
	r.date = &date
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) DefectReviewRequestedBy(defectReviewRequestedBy []int32) ApiFindingsListRequest {
	r.defectReviewRequestedBy = &defectReviewRequestedBy
	return r
}

func (r ApiFindingsListRequest) Description(description string) ApiFindingsListRequest {
	r.description = &description
	return r
}

func (r ApiFindingsListRequest) DiscoveredAfter(discoveredAfter string) ApiFindingsListRequest {
	r.discoveredAfter = &discoveredAfter
	return r
}

func (r ApiFindingsListRequest) DiscoveredBefore(discoveredBefore string) ApiFindingsListRequest {
	r.discoveredBefore = &discoveredBefore
	return r
}

func (r ApiFindingsListRequest) DiscoveredOn(discoveredOn string) ApiFindingsListRequest {
	r.discoveredOn = &discoveredOn
	return r
}

func (r ApiFindingsListRequest) Duplicate(duplicate bool) ApiFindingsListRequest {
	r.duplicate = &duplicate
	return r
}

func (r ApiFindingsListRequest) DuplicateFinding(duplicateFinding int32) ApiFindingsListRequest {
	r.duplicateFinding = &duplicateFinding
	return r
}

func (r ApiFindingsListRequest) DynamicFinding(dynamicFinding bool) ApiFindingsListRequest {
	r.dynamicFinding = &dynamicFinding
	return r
}

func (r ApiFindingsListRequest) EffortForFixing(effortForFixing string) ApiFindingsListRequest {
	r.effortForFixing = &effortForFixing
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) Endpoints(endpoints []int32) ApiFindingsListRequest {
	r.endpoints = &endpoints
	return r
}

func (r ApiFindingsListRequest) EpssPercentile(epssPercentile float32) ApiFindingsListRequest {
	r.epssPercentile = &epssPercentile
	return r
}

func (r ApiFindingsListRequest) EpssScore(epssScore float32) ApiFindingsListRequest {
	r.epssScore = &epssScore
	return r
}

func (r ApiFindingsListRequest) FalseP(falseP bool) ApiFindingsListRequest {
	r.falseP = &falseP
	return r
}

func (r ApiFindingsListRequest) FilePath(filePath string) ApiFindingsListRequest {
	r.filePath = &filePath
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) FindingGroup(findingGroup []float32) ApiFindingsListRequest {
	r.findingGroup = &findingGroup
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) FoundBy(foundBy []int32) ApiFindingsListRequest {
	r.foundBy = &foundBy
	return r
}

func (r ApiFindingsListRequest) HasJira(hasJira bool) ApiFindingsListRequest {
	r.hasJira = &hasJira
	return r
}

// Has tags
func (r ApiFindingsListRequest) HasTags(hasTags bool) ApiFindingsListRequest {
	r.hasTags = &hasTags
	return r
}

func (r ApiFindingsListRequest) HashCode(hashCode string) ApiFindingsListRequest {
	r.hashCode = &hashCode
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) Id(id []int32) ApiFindingsListRequest {
	r.id = &id
	return r
}

func (r ApiFindingsListRequest) Impact(impact string) ApiFindingsListRequest {
	r.impact = &impact
	return r
}

// Internal use tags sepcifically for maintaining parity with product. This field will be present as a subset in the tags field
func (r ApiFindingsListRequest) InheritedTags(inheritedTags [][]int32) ApiFindingsListRequest {
	r.inheritedTags = &inheritedTags
	return r
}

func (r ApiFindingsListRequest) IsMitigated(isMitigated bool) ApiFindingsListRequest {
	r.isMitigated = &isMitigated
	return r
}

// The date the linked Jira issue was last modified.  * &#x60;None&#x60; - Any date * &#x60;1&#x60; - Today * &#x60;2&#x60; - Past 7 days * &#x60;3&#x60; - Past 30 days * &#x60;4&#x60; - Past 90 days * &#x60;5&#x60; - Current month * &#x60;6&#x60; - Current year * &#x60;7&#x60; - Past year
func (r ApiFindingsListRequest) JiraChange(jiraChange time.Time) ApiFindingsListRequest {
	r.jiraChange = &jiraChange
	return r
}

// The date a Jira issue was created from this finding.  * &#x60;None&#x60; - Any date * &#x60;1&#x60; - Today * &#x60;2&#x60; - Past 7 days * &#x60;3&#x60; - Past 30 days * &#x60;4&#x60; - Past 90 days * &#x60;5&#x60; - Current month * &#x60;6&#x60; - Current year * &#x60;7&#x60; - Past year
func (r ApiFindingsListRequest) JiraCreation(jiraCreation time.Time) ApiFindingsListRequest {
	r.jiraCreation = &jiraCreation
	return r
}

// Provides the date the flaw was last &#39;touched&#39; by a tester.  * &#x60;None&#x60; - Any date * &#x60;1&#x60; - Today * &#x60;2&#x60; - Past 7 days * &#x60;3&#x60; - Past 30 days * &#x60;4&#x60; - Past 90 days * &#x60;5&#x60; - Current month * &#x60;6&#x60; - Current year * &#x60;7&#x60; - Past year
func (r ApiFindingsListRequest) LastReviewed(lastReviewed time.Time) ApiFindingsListRequest {
	r.lastReviewed = &lastReviewed
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) LastReviewedBy(lastReviewedBy []int32) ApiFindingsListRequest {
	r.lastReviewedBy = &lastReviewedBy
	return r
}

func (r ApiFindingsListRequest) LastStatusUpdate(lastStatusUpdate time.Time) ApiFindingsListRequest {
	r.lastStatusUpdate = &lastStatusUpdate
	return r
}

// Number of results to return per page.
func (r ApiFindingsListRequest) Limit(limit int32) ApiFindingsListRequest {
	r.limit = &limit
	return r
}

// Denotes if this flaw has been fixed by storing the date it was fixed.  * &#x60;None&#x60; - Any date * &#x60;1&#x60; - Today * &#x60;2&#x60; - Past 7 days * &#x60;3&#x60; - Past 30 days * &#x60;4&#x60; - Past 90 days * &#x60;5&#x60; - Current month * &#x60;6&#x60; - Current year * &#x60;7&#x60; - Past year
func (r ApiFindingsListRequest) Mitigated(mitigated time.Time) ApiFindingsListRequest {
	r.mitigated = &mitigated
	return r
}

func (r ApiFindingsListRequest) MitigatedAfter(mitigatedAfter string) ApiFindingsListRequest {
	r.mitigatedAfter = &mitigatedAfter
	return r
}

func (r ApiFindingsListRequest) MitigatedBefore(mitigatedBefore string) ApiFindingsListRequest {
	r.mitigatedBefore = &mitigatedBefore
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) MitigatedBy(mitigatedBy []int32) ApiFindingsListRequest {
	r.mitigatedBy = &mitigatedBy
	return r
}

func (r ApiFindingsListRequest) MitigatedOn(mitigatedOn string) ApiFindingsListRequest {
	r.mitigatedOn = &mitigatedOn
	return r
}

func (r ApiFindingsListRequest) Mitigation(mitigation string) ApiFindingsListRequest {
	r.mitigation = &mitigation
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) NbOccurences(nbOccurences []int32) ApiFindingsListRequest {
	r.nbOccurences = &nbOccurences
	return r
}

// Not Tag name contains
func (r ApiFindingsListRequest) NotTag(notTag string) ApiFindingsListRequest {
	r.notTag = &notTag
	return r
}

// Comma separated list of exact tags not present on model
func (r ApiFindingsListRequest) NotTags(notTags []string) ApiFindingsListRequest {
	r.notTags = &notTags
	return r
}

// Comma separated list of exact tags not present on product
func (r ApiFindingsListRequest) NotTestEngagementProductTags(notTestEngagementProductTags []string) ApiFindingsListRequest {
	r.notTestEngagementProductTags = &notTestEngagementProductTags
	return r
}

// Comma separated list of exact tags not present on engagement
func (r ApiFindingsListRequest) NotTestEngagementTags(notTestEngagementTags []string) ApiFindingsListRequest {
	r.notTestEngagementTags = &notTestEngagementTags
	return r
}

// Comma separated list of exact tags present on test
func (r ApiFindingsListRequest) NotTestTags(notTestTags []string) ApiFindingsListRequest {
	r.notTestTags = &notTestTags
	return r
}

func (r ApiFindingsListRequest) NumericalSeverity(numericalSeverity string) ApiFindingsListRequest {
	r.numericalSeverity = &numericalSeverity
	return r
}

// Ordering  * &#x60;active&#x60; - Active * &#x60;-active&#x60; - Active (descending) * &#x60;component_name&#x60; - Component name * &#x60;-component_name&#x60; - Component name (descending) * &#x60;component_version&#x60; - Component version * &#x60;-component_version&#x60; - Component version (descending) * &#x60;created&#x60; - Created * &#x60;-created&#x60; - Created (descending) * &#x60;last_status_update&#x60; - Last status update * &#x60;-last_status_update&#x60; - Last status update (descending) * &#x60;last_reviewed&#x60; - Last reviewed * &#x60;-last_reviewed&#x60; - Last reviewed (descending) * &#x60;cwe&#x60; - Cwe * &#x60;-cwe&#x60; - Cwe (descending) * &#x60;date&#x60; - Date * &#x60;-date&#x60; - Date (descending) * &#x60;duplicate&#x60; - Duplicate * &#x60;-duplicate&#x60; - Duplicate (descending) * &#x60;dynamic_finding&#x60; - Dynamic finding * &#x60;-dynamic_finding&#x60; - Dynamic finding (descending) * &#x60;false_p&#x60; - False p * &#x60;-false_p&#x60; - False p (descending) * &#x60;found_by&#x60; - Found by * &#x60;-found_by&#x60; - Found by (descending) * &#x60;id&#x60; - Id * &#x60;-id&#x60; - Id (descending) * &#x60;is_mitigated&#x60; - Is mitigated * &#x60;-is_mitigated&#x60; - Is mitigated (descending) * &#x60;numerical_severity&#x60; - Numerical severity * &#x60;-numerical_severity&#x60; - Numerical severity (descending) * &#x60;out_of_scope&#x60; - Out of scope * &#x60;-out_of_scope&#x60; - Out of scope (descending) * &#x60;severity&#x60; - Severity * &#x60;-severity&#x60; - Severity (descending) * &#x60;reviewers&#x60; - Reviewers * &#x60;-reviewers&#x60; - Reviewers (descending) * &#x60;static_finding&#x60; - Static finding * &#x60;-static_finding&#x60; - Static finding (descending) * &#x60;test__engagement__product__name&#x60; - Test  engagement  product  name * &#x60;-test__engagement__product__name&#x60; - Test  engagement  product  name (descending) * &#x60;title&#x60; - Title * &#x60;-title&#x60; - Title (descending) * &#x60;under_defect_review&#x60; - Under defect review * &#x60;-under_defect_review&#x60; - Under defect review (descending) * &#x60;under_review&#x60; - Under review * &#x60;-under_review&#x60; - Under review (descending) * &#x60;verified&#x60; - Verified * &#x60;-verified&#x60; - Verified (descending)
func (r ApiFindingsListRequest) O(o []string) ApiFindingsListRequest {
	r.o = &o
	return r
}

// The initial index from which to return the results.
func (r ApiFindingsListRequest) Offset(offset int32) ApiFindingsListRequest {
	r.offset = &offset
	return r
}

func (r ApiFindingsListRequest) OutOfScope(outOfScope bool) ApiFindingsListRequest {
	r.outOfScope = &outOfScope
	return r
}

func (r ApiFindingsListRequest) OutsideOfSla(outsideOfSla float32) ApiFindingsListRequest {
	r.outsideOfSla = &outsideOfSla
	return r
}

func (r ApiFindingsListRequest) Param(param string) ApiFindingsListRequest {
	r.param = &param
	return r
}

func (r ApiFindingsListRequest) Payload(payload string) ApiFindingsListRequest {
	r.payload = &payload
	return r
}

func (r ApiFindingsListRequest) PlannedRemediationDate(plannedRemediationDate string) ApiFindingsListRequest {
	r.plannedRemediationDate = &plannedRemediationDate
	return r
}

func (r ApiFindingsListRequest) PlannedRemediationVersion(plannedRemediationVersion string) ApiFindingsListRequest {
	r.plannedRemediationVersion = &plannedRemediationVersion
	return r
}

// List of fields for which to prefetch model instances and add those to the response
func (r ApiFindingsListRequest) Prefetch(prefetch []string) ApiFindingsListRequest {
	r.prefetch = &prefetch
	return r
}

// Comma separated list of exact product lifecycles
func (r ApiFindingsListRequest) ProductLifecycle(productLifecycle string) ApiFindingsListRequest {
	r.productLifecycle = &productLifecycle
	return r
}

// exact product name
func (r ApiFindingsListRequest) ProductName(productName string) ApiFindingsListRequest {
	r.productName = &productName
	return r
}

// exact product name
func (r ApiFindingsListRequest) ProductNameContains(productNameContains string) ApiFindingsListRequest {
	r.productNameContains = &productNameContains
	return r
}

func (r ApiFindingsListRequest) PublishDate(publishDate string) ApiFindingsListRequest {
	r.publishDate = &publishDate
	return r
}

func (r ApiFindingsListRequest) References(references string) ApiFindingsListRequest {
	r.references = &references
	return r
}

// Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)
func (r ApiFindingsListRequest) RelatedFields(relatedFields bool) ApiFindingsListRequest {
	r.relatedFields = &relatedFields
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) Reporter(reporter []int32) ApiFindingsListRequest {
	r.reporter = &reporter
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) ReviewRequestedBy(reviewRequestedBy []int32) ApiFindingsListRequest {
	r.reviewRequestedBy = &reviewRequestedBy
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) Reviewers(reviewers []int32) ApiFindingsListRequest {
	r.reviewers = &reviewers
	return r
}

func (r ApiFindingsListRequest) RiskAcceptance(riskAcceptance float32) ApiFindingsListRequest {
	r.riskAcceptance = &riskAcceptance
	return r
}

func (r ApiFindingsListRequest) RiskAccepted(riskAccepted bool) ApiFindingsListRequest {
	r.riskAccepted = &riskAccepted
	return r
}

func (r ApiFindingsListRequest) SastSinkObject(sastSinkObject string) ApiFindingsListRequest {
	r.sastSinkObject = &sastSinkObject
	return r
}

func (r ApiFindingsListRequest) SastSourceFilePath(sastSourceFilePath string) ApiFindingsListRequest {
	r.sastSourceFilePath = &sastSourceFilePath
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) SastSourceLine(sastSourceLine []int32) ApiFindingsListRequest {
	r.sastSourceLine = &sastSourceLine
	return r
}

func (r ApiFindingsListRequest) SastSourceObject(sastSourceObject string) ApiFindingsListRequest {
	r.sastSourceObject = &sastSourceObject
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) ScannerConfidence(scannerConfidence []int32) ApiFindingsListRequest {
	r.scannerConfidence = &scannerConfidence
	return r
}

func (r ApiFindingsListRequest) Service(service string) ApiFindingsListRequest {
	r.service = &service
	return r
}

func (r ApiFindingsListRequest) Severity(severity string) ApiFindingsListRequest {
	r.severity = &severity
	return r
}

func (r ApiFindingsListRequest) SeverityJustification(severityJustification string) ApiFindingsListRequest {
	r.severityJustification = &severityJustification
	return r
}

func (r ApiFindingsListRequest) SlaExpirationDate(slaExpirationDate string) ApiFindingsListRequest {
	r.slaExpirationDate = &slaExpirationDate
	return r
}

func (r ApiFindingsListRequest) SlaStartDate(slaStartDate string) ApiFindingsListRequest {
	r.slaStartDate = &slaStartDate
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) SonarqubeIssue(sonarqubeIssue []int32) ApiFindingsListRequest {
	r.sonarqubeIssue = &sonarqubeIssue
	return r
}

func (r ApiFindingsListRequest) StaticFinding(staticFinding bool) ApiFindingsListRequest {
	r.staticFinding = &staticFinding
	return r
}

func (r ApiFindingsListRequest) StepsToReproduce(stepsToReproduce string) ApiFindingsListRequest {
	r.stepsToReproduce = &stepsToReproduce
	return r
}

// Tag name contains
func (r ApiFindingsListRequest) Tag(tag string) ApiFindingsListRequest {
	r.tag = &tag
	return r
}

// Comma separated list of exact tags
func (r ApiFindingsListRequest) Tags(tags []string) ApiFindingsListRequest {
	r.tags = &tags
	return r
}

func (r ApiFindingsListRequest) Test(test int32) ApiFindingsListRequest {
	r.test = &test
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) TestEngagement(testEngagement []int32) ApiFindingsListRequest {
	r.testEngagement = &testEngagement
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) TestEngagementProduct(testEngagementProduct []int32) ApiFindingsListRequest {
	r.testEngagementProduct = &testEngagementProduct
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) TestEngagementProductProdType(testEngagementProductProdType []int32) ApiFindingsListRequest {
	r.testEngagementProductProdType = &testEngagementProductProdType
	return r
}

// Comma separated list of exact tags present on product
func (r ApiFindingsListRequest) TestEngagementProductTags(testEngagementProductTags []string) ApiFindingsListRequest {
	r.testEngagementProductTags = &testEngagementProductTags
	return r
}

// Comma separated list of exact tags present on engagement
func (r ApiFindingsListRequest) TestEngagementTags(testEngagementTags []string) ApiFindingsListRequest {
	r.testEngagementTags = &testEngagementTags
	return r
}

// Comma separated list of exact tags present on test
func (r ApiFindingsListRequest) TestTags(testTags []string) ApiFindingsListRequest {
	r.testTags = &testTags
	return r
}

// Multiple values may be separated by commas.
func (r ApiFindingsListRequest) TestTestType(testTestType []int32) ApiFindingsListRequest {
	r.testTestType = &testTestType
	return r
}

func (r ApiFindingsListRequest) Title(title string) ApiFindingsListRequest {
	r.title = &title
	return r
}

func (r ApiFindingsListRequest) UnderDefectReview(underDefectReview bool) ApiFindingsListRequest {
	r.underDefectReview = &underDefectReview
	return r
}

func (r ApiFindingsListRequest) UnderReview(underReview bool) ApiFindingsListRequest {
	r.underReview = &underReview
	return r
}

func (r ApiFindingsListRequest) UniqueIdFromTool(uniqueIdFromTool string) ApiFindingsListRequest {
	r.uniqueIdFromTool = &uniqueIdFromTool
	return r
}

func (r ApiFindingsListRequest) Verified(verified bool) ApiFindingsListRequest {
	r.verified = &verified
	return r
}

func (r ApiFindingsListRequest) VulnIdFromTool(vulnIdFromTool string) ApiFindingsListRequest {
	r.vulnIdFromTool = &vulnIdFromTool
	return r
}

func (r ApiFindingsListRequest) VulnerabilityId(vulnerabilityId string) ApiFindingsListRequest {
	r.vulnerabilityId = &vulnerabilityId
	return r
}

func (r ApiFindingsListRequest) Execute() (*PaginatedFindingList, *http.Response, error) {
	return r.ApiService.FindingsListExecute(r)
}

/*
FindingsList Method for FindingsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindingsListRequest
*/
func (a *FindingsAPIService) FindingsList(ctx context.Context) ApiFindingsListRequest {
	return ApiFindingsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedFindingList
func (a *FindingsAPIService) FindingsListExecute(r ApiFindingsListRequest) (*PaginatedFindingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedFindingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.componentName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "component_name", r.componentName, "form", "")
	}
	if r.componentVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "component_version", r.componentVersion, "form", "")
	}
	if r.created != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created", r.created, "form", "")
	}
	if r.cvssv3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cvssv3", r.cvssv3, "form", "")
	}
	if r.cvssv3Score != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cvssv3_score", r.cvssv3Score, "form", "")
	}
	if r.cwe != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cwe", r.cwe, "form", "csv")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.defectReviewRequestedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defect_review_requested_by", r.defectReviewRequestedBy, "form", "csv")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.discoveredAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discovered_after", r.discoveredAfter, "form", "")
	}
	if r.discoveredBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discovered_before", r.discoveredBefore, "form", "")
	}
	if r.discoveredOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "discovered_on", r.discoveredOn, "form", "")
	}
	if r.duplicate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duplicate", r.duplicate, "form", "")
	}
	if r.duplicateFinding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duplicate_finding", r.duplicateFinding, "form", "")
	}
	if r.dynamicFinding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dynamic_finding", r.dynamicFinding, "form", "")
	}
	if r.effortForFixing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "effort_for_fixing", r.effortForFixing, "form", "")
	}
	if r.endpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endpoints", r.endpoints, "form", "csv")
	}
	if r.epssPercentile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "epss_percentile", r.epssPercentile, "form", "")
	}
	if r.epssScore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "epss_score", r.epssScore, "form", "")
	}
	if r.falseP != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "false_p", r.falseP, "form", "")
	}
	if r.filePath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "file_path", r.filePath, "form", "")
	}
	if r.findingGroup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "finding_group", r.findingGroup, "form", "csv")
	}
	if r.foundBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "found_by", r.foundBy, "form", "csv")
	}
	if r.hasJira != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_jira", r.hasJira, "form", "")
	}
	if r.hasTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_tags", r.hasTags, "form", "")
	}
	if r.hashCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hash_code", r.hashCode, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "csv")
	}
	if r.impact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "impact", r.impact, "form", "")
	}
	if r.inheritedTags != nil {
		t := *r.inheritedTags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inherited_tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inherited_tags", t, "form", "multi")
		}
	}
	if r.isMitigated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_mitigated", r.isMitigated, "form", "")
	}
	if r.jiraChange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jira_change", r.jiraChange, "form", "")
	}
	if r.jiraCreation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jira_creation", r.jiraCreation, "form", "")
	}
	if r.lastReviewed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_reviewed", r.lastReviewed, "form", "")
	}
	if r.lastReviewedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_reviewed_by", r.lastReviewedBy, "form", "csv")
	}
	if r.lastStatusUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_status_update", r.lastStatusUpdate, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.mitigated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitigated", r.mitigated, "form", "")
	}
	if r.mitigatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitigated_after", r.mitigatedAfter, "form", "")
	}
	if r.mitigatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitigated_before", r.mitigatedBefore, "form", "")
	}
	if r.mitigatedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitigated_by", r.mitigatedBy, "form", "csv")
	}
	if r.mitigatedOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitigated_on", r.mitigatedOn, "form", "")
	}
	if r.mitigation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mitigation", r.mitigation, "form", "")
	}
	if r.nbOccurences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nb_occurences", r.nbOccurences, "form", "csv")
	}
	if r.notTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_tag", r.notTag, "form", "")
	}
	if r.notTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_tags", r.notTags, "form", "csv")
	}
	if r.notTestEngagementProductTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_test__engagement__product__tags", r.notTestEngagementProductTags, "form", "csv")
	}
	if r.notTestEngagementTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_test__engagement__tags", r.notTestEngagementTags, "form", "csv")
	}
	if r.notTestTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_test__tags", r.notTestTags, "form", "csv")
	}
	if r.numericalSeverity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numerical_severity", r.numericalSeverity, "form", "")
	}
	if r.o != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "o", r.o, "form", "csv")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.outOfScope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "out_of_scope", r.outOfScope, "form", "")
	}
	if r.outsideOfSla != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outside_of_sla", r.outsideOfSla, "form", "")
	}
	if r.param != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "param", r.param, "form", "")
	}
	if r.payload != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payload", r.payload, "form", "")
	}
	if r.plannedRemediationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "planned_remediation_date", r.plannedRemediationDate, "form", "")
	}
	if r.plannedRemediationVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "planned_remediation_version", r.plannedRemediationVersion, "form", "")
	}
	if r.prefetch != nil {
		t := *r.prefetch
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefetch", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefetch", t, "form", "multi")
		}
	}
	if r.productLifecycle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_lifecycle", r.productLifecycle, "form", "")
	}
	if r.productName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_name", r.productName, "form", "")
	}
	if r.productNameContains != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_name_contains", r.productNameContains, "form", "")
	}
	if r.publishDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "publish_date", r.publishDate, "form", "")
	}
	if r.references != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "references", r.references, "form", "")
	}
	if r.relatedFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "related_fields", r.relatedFields, "form", "")
	}
	if r.reporter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reporter", r.reporter, "form", "csv")
	}
	if r.reviewRequestedBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "review_requested_by", r.reviewRequestedBy, "form", "csv")
	}
	if r.reviewers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reviewers", r.reviewers, "form", "csv")
	}
	if r.riskAcceptance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "risk_acceptance", r.riskAcceptance, "form", "")
	}
	if r.riskAccepted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "risk_accepted", r.riskAccepted, "form", "")
	}
	if r.sastSinkObject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sast_sink_object", r.sastSinkObject, "form", "")
	}
	if r.sastSourceFilePath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sast_source_file_path", r.sastSourceFilePath, "form", "")
	}
	if r.sastSourceLine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sast_source_line", r.sastSourceLine, "form", "csv")
	}
	if r.sastSourceObject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sast_source_object", r.sastSourceObject, "form", "")
	}
	if r.scannerConfidence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scanner_confidence", r.scannerConfidence, "form", "csv")
	}
	if r.service != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service", r.service, "form", "")
	}
	if r.severity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "severity", r.severity, "form", "")
	}
	if r.severityJustification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "severity_justification", r.severityJustification, "form", "")
	}
	if r.slaExpirationDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sla_expiration_date", r.slaExpirationDate, "form", "")
	}
	if r.slaStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sla_start_date", r.slaStartDate, "form", "")
	}
	if r.sonarqubeIssue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sonarqube_issue", r.sonarqubeIssue, "form", "csv")
	}
	if r.staticFinding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static_finding", r.staticFinding, "form", "")
	}
	if r.stepsToReproduce != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "steps_to_reproduce", r.stepsToReproduce, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "csv")
	}
	if r.test != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test", r.test, "form", "")
	}
	if r.testEngagement != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test__engagement", r.testEngagement, "form", "csv")
	}
	if r.testEngagementProduct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test__engagement__product", r.testEngagementProduct, "form", "csv")
	}
	if r.testEngagementProductProdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test__engagement__product__prod_type", r.testEngagementProductProdType, "form", "csv")
	}
	if r.testEngagementProductTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test__engagement__product__tags", r.testEngagementProductTags, "form", "csv")
	}
	if r.testEngagementTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test__engagement__tags", r.testEngagementTags, "form", "csv")
	}
	if r.testTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test__tags", r.testTags, "form", "csv")
	}
	if r.testTestType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test__test_type", r.testTestType, "form", "csv")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.underDefectReview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "under_defect_review", r.underDefectReview, "form", "")
	}
	if r.underReview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "under_review", r.underReview, "form", "")
	}
	if r.uniqueIdFromTool != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unique_id_from_tool", r.uniqueIdFromTool, "form", "")
	}
	if r.verified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verified", r.verified, "form", "")
	}
	if r.vulnIdFromTool != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vuln_id_from_tool", r.vulnIdFromTool, "form", "")
	}
	if r.vulnerabilityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vulnerability_id", r.vulnerabilityId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsMetadataCreateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	findingMetaRequest *FindingMetaRequest
}

func (r ApiFindingsMetadataCreateRequest) FindingMetaRequest(findingMetaRequest FindingMetaRequest) ApiFindingsMetadataCreateRequest {
	r.findingMetaRequest = &findingMetaRequest
	return r
}

func (r ApiFindingsMetadataCreateRequest) Execute() (*FindingMeta, *http.Response, error) {
	return r.ApiService.FindingsMetadataCreateExecute(r)
}

/*
FindingsMetadataCreate Method for FindingsMetadataCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsMetadataCreateRequest
*/
func (a *FindingsAPIService) FindingsMetadataCreate(ctx context.Context, id int32) ApiFindingsMetadataCreateRequest {
	return ApiFindingsMetadataCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FindingMeta
func (a *FindingsAPIService) FindingsMetadataCreateExecute(r ApiFindingsMetadataCreateRequest) (*FindingMeta, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindingMeta
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsMetadataCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/metadata/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.findingMetaRequest == nil {
		return localVarReturnValue, nil, reportError("findingMetaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.findingMetaRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsMetadataDestroyRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	name *int32
}

// name of the metadata to retrieve. If name is empty, return all the                                     metadata associated with the finding
func (r ApiFindingsMetadataDestroyRequest) Name(name int32) ApiFindingsMetadataDestroyRequest {
	r.name = &name
	return r
}

func (r ApiFindingsMetadataDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.FindingsMetadataDestroyExecute(r)
}

/*
FindingsMetadataDestroy Method for FindingsMetadataDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsMetadataDestroyRequest
*/
func (a *FindingsAPIService) FindingsMetadataDestroy(ctx context.Context, id int32) ApiFindingsMetadataDestroyRequest {
	return ApiFindingsMetadataDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FindingsAPIService) FindingsMetadataDestroyExecute(r ApiFindingsMetadataDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsMetadataDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/metadata/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.name == nil {
		return nil, reportError("name is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFindingsMetadataListRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
}

func (r ApiFindingsMetadataListRequest) Execute() ([]FindingMeta, *http.Response, error) {
	return r.ApiService.FindingsMetadataListExecute(r)
}

/*
FindingsMetadataList Method for FindingsMetadataList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsMetadataListRequest
*/
func (a *FindingsAPIService) FindingsMetadataList(ctx context.Context, id int32) ApiFindingsMetadataListRequest {
	return ApiFindingsMetadataListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []FindingMeta
func (a *FindingsAPIService) FindingsMetadataListExecute(r ApiFindingsMetadataListRequest) ([]FindingMeta, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FindingMeta
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsMetadataList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/metadata/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsMetadataUpdateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	findingMetaRequest *FindingMetaRequest
}

func (r ApiFindingsMetadataUpdateRequest) FindingMetaRequest(findingMetaRequest FindingMetaRequest) ApiFindingsMetadataUpdateRequest {
	r.findingMetaRequest = &findingMetaRequest
	return r
}

func (r ApiFindingsMetadataUpdateRequest) Execute() (*FindingMeta, *http.Response, error) {
	return r.ApiService.FindingsMetadataUpdateExecute(r)
}

/*
FindingsMetadataUpdate Method for FindingsMetadataUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsMetadataUpdateRequest
*/
func (a *FindingsAPIService) FindingsMetadataUpdate(ctx context.Context, id int32) ApiFindingsMetadataUpdateRequest {
	return ApiFindingsMetadataUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FindingMeta
func (a *FindingsAPIService) FindingsMetadataUpdateExecute(r ApiFindingsMetadataUpdateRequest) (*FindingMeta, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindingMeta
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsMetadataUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/metadata/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.findingMetaRequest == nil {
		return localVarReturnValue, nil, reportError("findingMetaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.findingMetaRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsNotesCreateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	addNewNoteOptionRequest *AddNewNoteOptionRequest
}

func (r ApiFindingsNotesCreateRequest) AddNewNoteOptionRequest(addNewNoteOptionRequest AddNewNoteOptionRequest) ApiFindingsNotesCreateRequest {
	r.addNewNoteOptionRequest = &addNewNoteOptionRequest
	return r
}

func (r ApiFindingsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.FindingsNotesCreateExecute(r)
}

/*
FindingsNotesCreate Method for FindingsNotesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsNotesCreateRequest
*/
func (a *FindingsAPIService) FindingsNotesCreate(ctx context.Context, id int32) ApiFindingsNotesCreateRequest {
	return ApiFindingsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *FindingsAPIService) FindingsNotesCreateExecute(r ApiFindingsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addNewNoteOptionRequest == nil {
		return localVarReturnValue, nil, reportError("addNewNoteOptionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addNewNoteOptionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsNotesRetrieveRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
}

func (r ApiFindingsNotesRetrieveRequest) Execute() (*FindingToNotes, *http.Response, error) {
	return r.ApiService.FindingsNotesRetrieveExecute(r)
}

/*
FindingsNotesRetrieve Method for FindingsNotesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsNotesRetrieveRequest
*/
func (a *FindingsAPIService) FindingsNotesRetrieve(ctx context.Context, id int32) ApiFindingsNotesRetrieveRequest {
	return ApiFindingsNotesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FindingToNotes
func (a *FindingsAPIService) FindingsNotesRetrieveExecute(r ApiFindingsNotesRetrieveRequest) (*FindingToNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindingToNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsNotesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsOriginalCreateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	newFid int32
}

func (r ApiFindingsOriginalCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.FindingsOriginalCreateExecute(r)
}

/*
FindingsOriginalCreate Method for FindingsOriginalCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @param newFid
 @return ApiFindingsOriginalCreateRequest
*/
func (a *FindingsAPIService) FindingsOriginalCreate(ctx context.Context, id int32, newFid int32) ApiFindingsOriginalCreateRequest {
	return ApiFindingsOriginalCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		newFid: newFid,
	}
}

// Execute executes the request
func (a *FindingsAPIService) FindingsOriginalCreateExecute(r ApiFindingsOriginalCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsOriginalCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/original/{new_fid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"new_fid"+"}", url.PathEscape(parameterValueToString(r.newFid, "newFid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFindingsPartialUpdateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	patchedFindingRequest *PatchedFindingRequest
}

func (r ApiFindingsPartialUpdateRequest) PatchedFindingRequest(patchedFindingRequest PatchedFindingRequest) ApiFindingsPartialUpdateRequest {
	r.patchedFindingRequest = &patchedFindingRequest
	return r
}

func (r ApiFindingsPartialUpdateRequest) Execute() (*Finding, *http.Response, error) {
	return r.ApiService.FindingsPartialUpdateExecute(r)
}

/*
FindingsPartialUpdate Method for FindingsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsPartialUpdateRequest
*/
func (a *FindingsAPIService) FindingsPartialUpdate(ctx context.Context, id int32) ApiFindingsPartialUpdateRequest {
	return ApiFindingsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Finding
func (a *FindingsAPIService) FindingsPartialUpdateExecute(r ApiFindingsPartialUpdateRequest) (*Finding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Finding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedFindingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsRemoveNotePartialUpdateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	patchedFindingNoteRequest *PatchedFindingNoteRequest
}

func (r ApiFindingsRemoveNotePartialUpdateRequest) PatchedFindingNoteRequest(patchedFindingNoteRequest PatchedFindingNoteRequest) ApiFindingsRemoveNotePartialUpdateRequest {
	r.patchedFindingNoteRequest = &patchedFindingNoteRequest
	return r
}

func (r ApiFindingsRemoveNotePartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.FindingsRemoveNotePartialUpdateExecute(r)
}

/*
FindingsRemoveNotePartialUpdate Method for FindingsRemoveNotePartialUpdate

Remove Note From Finding Note

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsRemoveNotePartialUpdateRequest
*/
func (a *FindingsAPIService) FindingsRemoveNotePartialUpdate(ctx context.Context, id int32) ApiFindingsRemoveNotePartialUpdateRequest {
	return ApiFindingsRemoveNotePartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FindingsAPIService) FindingsRemoveNotePartialUpdateExecute(r ApiFindingsRemoveNotePartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsRemoveNotePartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/remove_note/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedFindingNoteRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFindingsRemoveTagsPartialUpdateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	patchedTagRequest *PatchedTagRequest
}

func (r ApiFindingsRemoveTagsPartialUpdateRequest) PatchedTagRequest(patchedTagRequest PatchedTagRequest) ApiFindingsRemoveTagsPartialUpdateRequest {
	r.patchedTagRequest = &patchedTagRequest
	return r
}

func (r ApiFindingsRemoveTagsPartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.FindingsRemoveTagsPartialUpdateExecute(r)
}

/*
FindingsRemoveTagsPartialUpdate Method for FindingsRemoveTagsPartialUpdate

Remove Tag(s) from finding list of tags

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsRemoveTagsPartialUpdateRequest
*/
func (a *FindingsAPIService) FindingsRemoveTagsPartialUpdate(ctx context.Context, id int32) ApiFindingsRemoveTagsPartialUpdateRequest {
	return ApiFindingsRemoveTagsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FindingsAPIService) FindingsRemoveTagsPartialUpdateExecute(r ApiFindingsRemoveTagsPartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsRemoveTagsPartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/remove_tags/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTagRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFindingsRemoveTagsUpdateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	tagRequest *TagRequest
}

func (r ApiFindingsRemoveTagsUpdateRequest) TagRequest(tagRequest TagRequest) ApiFindingsRemoveTagsUpdateRequest {
	r.tagRequest = &tagRequest
	return r
}

func (r ApiFindingsRemoveTagsUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.FindingsRemoveTagsUpdateExecute(r)
}

/*
FindingsRemoveTagsUpdate Method for FindingsRemoveTagsUpdate

Remove Tag(s) from finding list of tags

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsRemoveTagsUpdateRequest
*/
func (a *FindingsAPIService) FindingsRemoveTagsUpdate(ctx context.Context, id int32) ApiFindingsRemoveTagsUpdateRequest {
	return ApiFindingsRemoveTagsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *FindingsAPIService) FindingsRemoveTagsUpdateExecute(r ApiFindingsRemoveTagsUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsRemoveTagsUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/remove_tags/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tagRequest == nil {
		return nil, reportError("tagRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFindingsRequestResponseCreateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	burpRawRequestResponseRequest *BurpRawRequestResponseRequest
}

func (r ApiFindingsRequestResponseCreateRequest) BurpRawRequestResponseRequest(burpRawRequestResponseRequest BurpRawRequestResponseRequest) ApiFindingsRequestResponseCreateRequest {
	r.burpRawRequestResponseRequest = &burpRawRequestResponseRequest
	return r
}

func (r ApiFindingsRequestResponseCreateRequest) Execute() (*BurpRawRequestResponse, *http.Response, error) {
	return r.ApiService.FindingsRequestResponseCreateExecute(r)
}

/*
FindingsRequestResponseCreate Method for FindingsRequestResponseCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsRequestResponseCreateRequest
*/
func (a *FindingsAPIService) FindingsRequestResponseCreate(ctx context.Context, id int32) ApiFindingsRequestResponseCreateRequest {
	return ApiFindingsRequestResponseCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BurpRawRequestResponse
func (a *FindingsAPIService) FindingsRequestResponseCreateExecute(r ApiFindingsRequestResponseCreateRequest) (*BurpRawRequestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BurpRawRequestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsRequestResponseCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/request_response/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.burpRawRequestResponseRequest == nil {
		return localVarReturnValue, nil, reportError("burpRawRequestResponseRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.burpRawRequestResponseRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsRequestResponseRetrieveRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
}

func (r ApiFindingsRequestResponseRetrieveRequest) Execute() (*BurpRawRequestResponse, *http.Response, error) {
	return r.ApiService.FindingsRequestResponseRetrieveExecute(r)
}

/*
FindingsRequestResponseRetrieve Method for FindingsRequestResponseRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsRequestResponseRetrieveRequest
*/
func (a *FindingsAPIService) FindingsRequestResponseRetrieve(ctx context.Context, id int32) ApiFindingsRequestResponseRetrieveRequest {
	return ApiFindingsRequestResponseRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BurpRawRequestResponse
func (a *FindingsAPIService) FindingsRequestResponseRetrieveExecute(r ApiFindingsRequestResponseRetrieveRequest) (*BurpRawRequestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BurpRawRequestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsRequestResponseRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/request_response/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsRetrieveRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	prefetch *[]string
	relatedFields *bool
}

// List of fields for which to prefetch model instances and add those to the response
func (r ApiFindingsRetrieveRequest) Prefetch(prefetch []string) ApiFindingsRetrieveRequest {
	r.prefetch = &prefetch
	return r
}

// Expand finding external relations (engagement, environment, product,                                             product_type, test, test_type)
func (r ApiFindingsRetrieveRequest) RelatedFields(relatedFields bool) ApiFindingsRetrieveRequest {
	r.relatedFields = &relatedFields
	return r
}

func (r ApiFindingsRetrieveRequest) Execute() (*Finding, *http.Response, error) {
	return r.ApiService.FindingsRetrieveExecute(r)
}

/*
FindingsRetrieve Method for FindingsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsRetrieveRequest
*/
func (a *FindingsAPIService) FindingsRetrieve(ctx context.Context, id int32) ApiFindingsRetrieveRequest {
	return ApiFindingsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Finding
func (a *FindingsAPIService) FindingsRetrieveExecute(r ApiFindingsRetrieveRequest) (*Finding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Finding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.prefetch != nil {
		t := *r.prefetch
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "prefetch", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "prefetch", t, "form", "multi")
		}
	}
	if r.relatedFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "related_fields", r.relatedFields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsTagsCreateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	tagRequest *TagRequest
}

func (r ApiFindingsTagsCreateRequest) TagRequest(tagRequest TagRequest) ApiFindingsTagsCreateRequest {
	r.tagRequest = &tagRequest
	return r
}

func (r ApiFindingsTagsCreateRequest) Execute() (*Tag, *http.Response, error) {
	return r.ApiService.FindingsTagsCreateExecute(r)
}

/*
FindingsTagsCreate Method for FindingsTagsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsTagsCreateRequest
*/
func (a *FindingsAPIService) FindingsTagsCreate(ctx context.Context, id int32) ApiFindingsTagsCreateRequest {
	return ApiFindingsTagsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Tag
func (a *FindingsAPIService) FindingsTagsCreateExecute(r ApiFindingsTagsCreateRequest) (*Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsTagsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/tags/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tagRequest == nil {
		return localVarReturnValue, nil, reportError("tagRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsTagsRetrieveRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
}

func (r ApiFindingsTagsRetrieveRequest) Execute() (*Tag, *http.Response, error) {
	return r.ApiService.FindingsTagsRetrieveExecute(r)
}

/*
FindingsTagsRetrieve Method for FindingsTagsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsTagsRetrieveRequest
*/
func (a *FindingsAPIService) FindingsTagsRetrieve(ctx context.Context, id int32) ApiFindingsTagsRetrieveRequest {
	return ApiFindingsTagsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Tag
func (a *FindingsAPIService) FindingsTagsRetrieveExecute(r ApiFindingsTagsRetrieveRequest) (*Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsTagsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/tags/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindingsUpdateRequest struct {
	ctx context.Context
	ApiService FindingsAPI
	id int32
	findingRequest *FindingRequest
}

func (r ApiFindingsUpdateRequest) FindingRequest(findingRequest FindingRequest) ApiFindingsUpdateRequest {
	r.findingRequest = &findingRequest
	return r
}

func (r ApiFindingsUpdateRequest) Execute() (*Finding, *http.Response, error) {
	return r.ApiService.FindingsUpdateExecute(r)
}

/*
FindingsUpdate Method for FindingsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this finding.
 @return ApiFindingsUpdateRequest
*/
func (a *FindingsAPIService) FindingsUpdate(ctx context.Context, id int32) ApiFindingsUpdateRequest {
	return ApiFindingsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Finding
func (a *FindingsAPIService) FindingsUpdateExecute(r ApiFindingsUpdateRequest) (*Finding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Finding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FindingsAPIService.FindingsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/findings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.findingRequest == nil {
		return localVarReturnValue, nil, reportError("findingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.findingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
