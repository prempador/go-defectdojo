/*
Defect Dojo API v2

Defect Dojo - Open Source vulnerability Management made easy. Prefetch related parameters/responses not yet in the schema.

API version: 2.30.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package defectdojo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"time"
)


type EngagementsAPI interface {

	/*
	EngagementsAcceptRisksCreate Method for EngagementsAcceptRisksCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsAcceptRisksCreateRequest
	*/
	EngagementsAcceptRisksCreate(ctx context.Context, id int32) ApiEngagementsAcceptRisksCreateRequest

	// EngagementsAcceptRisksCreateExecute executes the request
	//  @return []RiskAcceptance
	EngagementsAcceptRisksCreateExecute(r ApiEngagementsAcceptRisksCreateRequest) ([]RiskAcceptance, *http.Response, error)

	/*
	EngagementsCloseCreate Method for EngagementsCloseCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsCloseCreateRequest
	*/
	EngagementsCloseCreate(ctx context.Context, id int32) ApiEngagementsCloseCreateRequest

	// EngagementsCloseCreateExecute executes the request
	EngagementsCloseCreateExecute(r ApiEngagementsCloseCreateRequest) (*http.Response, error)

	/*
	EngagementsCompleteChecklistCreate Method for EngagementsCompleteChecklistCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsCompleteChecklistCreateRequest
	*/
	EngagementsCompleteChecklistCreate(ctx context.Context, id int32) ApiEngagementsCompleteChecklistCreateRequest

	// EngagementsCompleteChecklistCreateExecute executes the request
	//  @return EngagementCheckList
	EngagementsCompleteChecklistCreateExecute(r ApiEngagementsCompleteChecklistCreateRequest) (*EngagementCheckList, *http.Response, error)

	/*
	EngagementsCompleteChecklistRetrieve Method for EngagementsCompleteChecklistRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsCompleteChecklistRetrieveRequest
	*/
	EngagementsCompleteChecklistRetrieve(ctx context.Context, id int32) ApiEngagementsCompleteChecklistRetrieveRequest

	// EngagementsCompleteChecklistRetrieveExecute executes the request
	//  @return Engagement
	EngagementsCompleteChecklistRetrieveExecute(r ApiEngagementsCompleteChecklistRetrieveRequest) (*Engagement, *http.Response, error)

	/*
	EngagementsCreate Method for EngagementsCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEngagementsCreateRequest
	*/
	EngagementsCreate(ctx context.Context) ApiEngagementsCreateRequest

	// EngagementsCreateExecute executes the request
	//  @return Engagement
	EngagementsCreateExecute(r ApiEngagementsCreateRequest) (*Engagement, *http.Response, error)

	/*
	EngagementsDeletePreviewList Method for EngagementsDeletePreviewList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsDeletePreviewListRequest
	*/
	EngagementsDeletePreviewList(ctx context.Context, id int32) ApiEngagementsDeletePreviewListRequest

	// EngagementsDeletePreviewListExecute executes the request
	//  @return PaginatedDeletePreviewList
	EngagementsDeletePreviewListExecute(r ApiEngagementsDeletePreviewListRequest) (*PaginatedDeletePreviewList, *http.Response, error)

	/*
	EngagementsDestroy Method for EngagementsDestroy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsDestroyRequest
	*/
	EngagementsDestroy(ctx context.Context, id int32) ApiEngagementsDestroyRequest

	// EngagementsDestroyExecute executes the request
	EngagementsDestroyExecute(r ApiEngagementsDestroyRequest) (*http.Response, error)

	/*
	EngagementsFilesCreate Method for EngagementsFilesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsFilesCreateRequest
	*/
	EngagementsFilesCreate(ctx context.Context, id int32) ApiEngagementsFilesCreateRequest

	// EngagementsFilesCreateExecute executes the request
	//  @return File
	EngagementsFilesCreateExecute(r ApiEngagementsFilesCreateRequest) (*File, *http.Response, error)

	/*
	EngagementsFilesDownloadRetrieve Method for EngagementsFilesDownloadRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fileId
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsFilesDownloadRetrieveRequest
	*/
	EngagementsFilesDownloadRetrieve(ctx context.Context, fileId string, id int32) ApiEngagementsFilesDownloadRetrieveRequest

	// EngagementsFilesDownloadRetrieveExecute executes the request
	//  @return RawFile
	EngagementsFilesDownloadRetrieveExecute(r ApiEngagementsFilesDownloadRetrieveRequest) (*RawFile, *http.Response, error)

	/*
	EngagementsFilesRetrieve Method for EngagementsFilesRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsFilesRetrieveRequest
	*/
	EngagementsFilesRetrieve(ctx context.Context, id int32) ApiEngagementsFilesRetrieveRequest

	// EngagementsFilesRetrieveExecute executes the request
	//  @return EngagementToFiles
	EngagementsFilesRetrieveExecute(r ApiEngagementsFilesRetrieveRequest) (*EngagementToFiles, *http.Response, error)

	/*
	EngagementsGenerateReportCreate Method for EngagementsGenerateReportCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsGenerateReportCreateRequest
	*/
	EngagementsGenerateReportCreate(ctx context.Context, id int32) ApiEngagementsGenerateReportCreateRequest

	// EngagementsGenerateReportCreateExecute executes the request
	//  @return ReportGenerate
	EngagementsGenerateReportCreateExecute(r ApiEngagementsGenerateReportCreateRequest) (*ReportGenerate, *http.Response, error)

	/*
	EngagementsList Method for EngagementsList

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEngagementsListRequest
	*/
	EngagementsList(ctx context.Context) ApiEngagementsListRequest

	// EngagementsListExecute executes the request
	//  @return PaginatedEngagementList
	EngagementsListExecute(r ApiEngagementsListRequest) (*PaginatedEngagementList, *http.Response, error)

	/*
	EngagementsNotesCreate Method for EngagementsNotesCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsNotesCreateRequest
	*/
	EngagementsNotesCreate(ctx context.Context, id int32) ApiEngagementsNotesCreateRequest

	// EngagementsNotesCreateExecute executes the request
	//  @return Note
	EngagementsNotesCreateExecute(r ApiEngagementsNotesCreateRequest) (*Note, *http.Response, error)

	/*
	EngagementsNotesRetrieve Method for EngagementsNotesRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsNotesRetrieveRequest
	*/
	EngagementsNotesRetrieve(ctx context.Context, id int32) ApiEngagementsNotesRetrieveRequest

	// EngagementsNotesRetrieveExecute executes the request
	//  @return EngagementToNotes
	EngagementsNotesRetrieveExecute(r ApiEngagementsNotesRetrieveRequest) (*EngagementToNotes, *http.Response, error)

	/*
	EngagementsPartialUpdate Method for EngagementsPartialUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsPartialUpdateRequest
	*/
	EngagementsPartialUpdate(ctx context.Context, id int32) ApiEngagementsPartialUpdateRequest

	// EngagementsPartialUpdateExecute executes the request
	//  @return Engagement
	EngagementsPartialUpdateExecute(r ApiEngagementsPartialUpdateRequest) (*Engagement, *http.Response, error)

	/*
	EngagementsReopenCreate Method for EngagementsReopenCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsReopenCreateRequest
	*/
	EngagementsReopenCreate(ctx context.Context, id int32) ApiEngagementsReopenCreateRequest

	// EngagementsReopenCreateExecute executes the request
	EngagementsReopenCreateExecute(r ApiEngagementsReopenCreateRequest) (*http.Response, error)

	/*
	EngagementsRetrieve Method for EngagementsRetrieve

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsRetrieveRequest
	*/
	EngagementsRetrieve(ctx context.Context, id int32) ApiEngagementsRetrieveRequest

	// EngagementsRetrieveExecute executes the request
	//  @return Engagement
	EngagementsRetrieveExecute(r ApiEngagementsRetrieveRequest) (*Engagement, *http.Response, error)

	/*
	EngagementsUpdate Method for EngagementsUpdate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id A unique integer value identifying this engagement.
	@return ApiEngagementsUpdateRequest
	*/
	EngagementsUpdate(ctx context.Context, id int32) ApiEngagementsUpdateRequest

	// EngagementsUpdateExecute executes the request
	//  @return Engagement
	EngagementsUpdateExecute(r ApiEngagementsUpdateRequest) (*Engagement, *http.Response, error)
}

// EngagementsAPIService EngagementsAPI service
type EngagementsAPIService service

type ApiEngagementsAcceptRisksCreateRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
	acceptedRiskRequest *[]AcceptedRiskRequest
}

func (r ApiEngagementsAcceptRisksCreateRequest) AcceptedRiskRequest(acceptedRiskRequest []AcceptedRiskRequest) ApiEngagementsAcceptRisksCreateRequest {
	r.acceptedRiskRequest = &acceptedRiskRequest
	return r
}

func (r ApiEngagementsAcceptRisksCreateRequest) Execute() ([]RiskAcceptance, *http.Response, error) {
	return r.ApiService.EngagementsAcceptRisksCreateExecute(r)
}

/*
EngagementsAcceptRisksCreate Method for EngagementsAcceptRisksCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsAcceptRisksCreateRequest
*/
func (a *EngagementsAPIService) EngagementsAcceptRisksCreate(ctx context.Context, id int32) ApiEngagementsAcceptRisksCreateRequest {
	return ApiEngagementsAcceptRisksCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []RiskAcceptance
func (a *EngagementsAPIService) EngagementsAcceptRisksCreateExecute(r ApiEngagementsAcceptRisksCreateRequest) ([]RiskAcceptance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RiskAcceptance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsAcceptRisksCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/accept_risks/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.acceptedRiskRequest == nil {
		return localVarReturnValue, nil, reportError("acceptedRiskRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.acceptedRiskRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngagementsCloseCreateRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
}

func (r ApiEngagementsCloseCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EngagementsCloseCreateExecute(r)
}

/*
EngagementsCloseCreate Method for EngagementsCloseCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsCloseCreateRequest
*/
func (a *EngagementsAPIService) EngagementsCloseCreate(ctx context.Context, id int32) ApiEngagementsCloseCreateRequest {
	return ApiEngagementsCloseCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EngagementsAPIService) EngagementsCloseCreateExecute(r ApiEngagementsCloseCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsCloseCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/close/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEngagementsCompleteChecklistCreateRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
	engagementCheckListRequest *EngagementCheckListRequest
}

func (r ApiEngagementsCompleteChecklistCreateRequest) EngagementCheckListRequest(engagementCheckListRequest EngagementCheckListRequest) ApiEngagementsCompleteChecklistCreateRequest {
	r.engagementCheckListRequest = &engagementCheckListRequest
	return r
}

func (r ApiEngagementsCompleteChecklistCreateRequest) Execute() (*EngagementCheckList, *http.Response, error) {
	return r.ApiService.EngagementsCompleteChecklistCreateExecute(r)
}

/*
EngagementsCompleteChecklistCreate Method for EngagementsCompleteChecklistCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsCompleteChecklistCreateRequest
*/
func (a *EngagementsAPIService) EngagementsCompleteChecklistCreate(ctx context.Context, id int32) ApiEngagementsCompleteChecklistCreateRequest {
	return ApiEngagementsCompleteChecklistCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return EngagementCheckList
func (a *EngagementsAPIService) EngagementsCompleteChecklistCreateExecute(r ApiEngagementsCompleteChecklistCreateRequest) (*EngagementCheckList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EngagementCheckList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsCompleteChecklistCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/complete_checklist/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.engagementCheckListRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngagementsCompleteChecklistRetrieveRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
}

func (r ApiEngagementsCompleteChecklistRetrieveRequest) Execute() (*Engagement, *http.Response, error) {
	return r.ApiService.EngagementsCompleteChecklistRetrieveExecute(r)
}

/*
EngagementsCompleteChecklistRetrieve Method for EngagementsCompleteChecklistRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsCompleteChecklistRetrieveRequest
*/
func (a *EngagementsAPIService) EngagementsCompleteChecklistRetrieve(ctx context.Context, id int32) ApiEngagementsCompleteChecklistRetrieveRequest {
	return ApiEngagementsCompleteChecklistRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Engagement
func (a *EngagementsAPIService) EngagementsCompleteChecklistRetrieveExecute(r ApiEngagementsCompleteChecklistRetrieveRequest) (*Engagement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Engagement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsCompleteChecklistRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/complete_checklist/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngagementsCreateRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	engagementRequest *EngagementRequest
}

func (r ApiEngagementsCreateRequest) EngagementRequest(engagementRequest EngagementRequest) ApiEngagementsCreateRequest {
	r.engagementRequest = &engagementRequest
	return r
}

func (r ApiEngagementsCreateRequest) Execute() (*Engagement, *http.Response, error) {
	return r.ApiService.EngagementsCreateExecute(r)
}

/*
EngagementsCreate Method for EngagementsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEngagementsCreateRequest
*/
func (a *EngagementsAPIService) EngagementsCreate(ctx context.Context) ApiEngagementsCreateRequest {
	return ApiEngagementsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Engagement
func (a *EngagementsAPIService) EngagementsCreateExecute(r ApiEngagementsCreateRequest) (*Engagement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Engagement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.engagementRequest == nil {
		return localVarReturnValue, nil, reportError("engagementRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.engagementRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngagementsDeletePreviewListRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEngagementsDeletePreviewListRequest) Limit(limit int32) ApiEngagementsDeletePreviewListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEngagementsDeletePreviewListRequest) Offset(offset int32) ApiEngagementsDeletePreviewListRequest {
	r.offset = &offset
	return r
}

func (r ApiEngagementsDeletePreviewListRequest) Execute() (*PaginatedDeletePreviewList, *http.Response, error) {
	return r.ApiService.EngagementsDeletePreviewListExecute(r)
}

/*
EngagementsDeletePreviewList Method for EngagementsDeletePreviewList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsDeletePreviewListRequest
*/
func (a *EngagementsAPIService) EngagementsDeletePreviewList(ctx context.Context, id int32) ApiEngagementsDeletePreviewListRequest {
	return ApiEngagementsDeletePreviewListRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaginatedDeletePreviewList
func (a *EngagementsAPIService) EngagementsDeletePreviewListExecute(r ApiEngagementsDeletePreviewListRequest) (*PaginatedDeletePreviewList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDeletePreviewList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsDeletePreviewList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/delete_preview/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngagementsDestroyRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
}

func (r ApiEngagementsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EngagementsDestroyExecute(r)
}

/*
EngagementsDestroy Method for EngagementsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsDestroyRequest
*/
func (a *EngagementsAPIService) EngagementsDestroy(ctx context.Context, id int32) ApiEngagementsDestroyRequest {
	return ApiEngagementsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EngagementsAPIService) EngagementsDestroyExecute(r ApiEngagementsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEngagementsFilesCreateRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
	title *string
	file *os.File
}

func (r ApiEngagementsFilesCreateRequest) Title(title string) ApiEngagementsFilesCreateRequest {
	r.title = &title
	return r
}

func (r ApiEngagementsFilesCreateRequest) File(file *os.File) ApiEngagementsFilesCreateRequest {
	r.file = file
	return r
}

func (r ApiEngagementsFilesCreateRequest) Execute() (*File, *http.Response, error) {
	return r.ApiService.EngagementsFilesCreateExecute(r)
}

/*
EngagementsFilesCreate Method for EngagementsFilesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsFilesCreateRequest
*/
func (a *EngagementsAPIService) EngagementsFilesCreate(ctx context.Context, id int32) ApiEngagementsFilesCreateRequest {
	return ApiEngagementsFilesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return File
func (a *EngagementsAPIService) EngagementsFilesCreateExecute(r ApiEngagementsFilesCreateRequest) (*File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsFilesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/files/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if strlen(*r.title) < 1 {
		return localVarReturnValue, nil, reportError("title must have at least 1 elements")
	}
	if strlen(*r.title) > 100 {
		return localVarReturnValue, nil, reportError("title must have less than 100 elements")
	}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "")
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngagementsFilesDownloadRetrieveRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	fileId string
	id int32
}

func (r ApiEngagementsFilesDownloadRetrieveRequest) Execute() (*RawFile, *http.Response, error) {
	return r.ApiService.EngagementsFilesDownloadRetrieveExecute(r)
}

/*
EngagementsFilesDownloadRetrieve Method for EngagementsFilesDownloadRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileId
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsFilesDownloadRetrieveRequest
*/
func (a *EngagementsAPIService) EngagementsFilesDownloadRetrieve(ctx context.Context, fileId string, id int32) ApiEngagementsFilesDownloadRetrieveRequest {
	return ApiEngagementsFilesDownloadRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
		id: id,
	}
}

// Execute executes the request
//  @return RawFile
func (a *EngagementsAPIService) EngagementsFilesDownloadRetrieveExecute(r ApiEngagementsFilesDownloadRetrieveRequest) (*RawFile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RawFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsFilesDownloadRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/files/download/{file_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"file_id"+"}", url.PathEscape(parameterValueToString(r.fileId, "fileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngagementsFilesRetrieveRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
}

func (r ApiEngagementsFilesRetrieveRequest) Execute() (*EngagementToFiles, *http.Response, error) {
	return r.ApiService.EngagementsFilesRetrieveExecute(r)
}

/*
EngagementsFilesRetrieve Method for EngagementsFilesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsFilesRetrieveRequest
*/
func (a *EngagementsAPIService) EngagementsFilesRetrieve(ctx context.Context, id int32) ApiEngagementsFilesRetrieveRequest {
	return ApiEngagementsFilesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return EngagementToFiles
func (a *EngagementsAPIService) EngagementsFilesRetrieveExecute(r ApiEngagementsFilesRetrieveRequest) (*EngagementToFiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EngagementToFiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsFilesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/files/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngagementsGenerateReportCreateRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
	reportGenerateOptionRequest *ReportGenerateOptionRequest
}

func (r ApiEngagementsGenerateReportCreateRequest) ReportGenerateOptionRequest(reportGenerateOptionRequest ReportGenerateOptionRequest) ApiEngagementsGenerateReportCreateRequest {
	r.reportGenerateOptionRequest = &reportGenerateOptionRequest
	return r
}

func (r ApiEngagementsGenerateReportCreateRequest) Execute() (*ReportGenerate, *http.Response, error) {
	return r.ApiService.EngagementsGenerateReportCreateExecute(r)
}

/*
EngagementsGenerateReportCreate Method for EngagementsGenerateReportCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsGenerateReportCreateRequest
*/
func (a *EngagementsAPIService) EngagementsGenerateReportCreate(ctx context.Context, id int32) ApiEngagementsGenerateReportCreateRequest {
	return ApiEngagementsGenerateReportCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReportGenerate
func (a *EngagementsAPIService) EngagementsGenerateReportCreateExecute(r ApiEngagementsGenerateReportCreateRequest) (*ReportGenerate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReportGenerate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsGenerateReportCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/generate_report/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reportGenerateOptionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngagementsListRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	active *bool
	apiTest *bool
	hasTags *bool
	id *int32
	limit *int32
	name *string
	notProductTags *[]string
	notTag *string
	notTags *[]string
	o *[]string
	offset *int32
	penTest *bool
	product *int32
	productProdType *[]int32
	productTags *[]string
	reportType *int32
	requester *int32
	status *string
	tag *string
	tags *[]string
	targetEnd *string
	targetStart *string
	threatModel *bool
	updated *time.Time
	version *string
}

func (r ApiEngagementsListRequest) Active(active bool) ApiEngagementsListRequest {
	r.active = &active
	return r
}

func (r ApiEngagementsListRequest) ApiTest(apiTest bool) ApiEngagementsListRequest {
	r.apiTest = &apiTest
	return r
}

// Has tags
func (r ApiEngagementsListRequest) HasTags(hasTags bool) ApiEngagementsListRequest {
	r.hasTags = &hasTags
	return r
}

func (r ApiEngagementsListRequest) Id(id int32) ApiEngagementsListRequest {
	r.id = &id
	return r
}

// Number of results to return per page.
func (r ApiEngagementsListRequest) Limit(limit int32) ApiEngagementsListRequest {
	r.limit = &limit
	return r
}

func (r ApiEngagementsListRequest) Name(name string) ApiEngagementsListRequest {
	r.name = &name
	return r
}

// Comma separated list of exact tags not present on product
func (r ApiEngagementsListRequest) NotProductTags(notProductTags []string) ApiEngagementsListRequest {
	r.notProductTags = &notProductTags
	return r
}

// Not Tag name contains
func (r ApiEngagementsListRequest) NotTag(notTag string) ApiEngagementsListRequest {
	r.notTag = &notTag
	return r
}

// Comma separated list of exact tags not present on model
func (r ApiEngagementsListRequest) NotTags(notTags []string) ApiEngagementsListRequest {
	r.notTags = &notTags
	return r
}

// Ordering  * &#x60;name&#x60; - Engagement Name * &#x60;-name&#x60; - Engagement Name (descending) * &#x60;version&#x60; - Version * &#x60;-version&#x60; - Version (descending) * &#x60;target_start&#x60; - Target start * &#x60;-target_start&#x60; - Target start (descending) * &#x60;target_end&#x60; - Target end * &#x60;-target_end&#x60; - Target end (descending) * &#x60;status&#x60; - Status * &#x60;-status&#x60; - Status (descending) * &#x60;lead&#x60; - Lead * &#x60;-lead&#x60; - Lead (descending) * &#x60;created&#x60; - Created * &#x60;-created&#x60; - Created (descending) * &#x60;updated&#x60; - Updated * &#x60;-updated&#x60; - Updated (descending)
func (r ApiEngagementsListRequest) O(o []string) ApiEngagementsListRequest {
	r.o = &o
	return r
}

// The initial index from which to return the results.
func (r ApiEngagementsListRequest) Offset(offset int32) ApiEngagementsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEngagementsListRequest) PenTest(penTest bool) ApiEngagementsListRequest {
	r.penTest = &penTest
	return r
}

func (r ApiEngagementsListRequest) Product(product int32) ApiEngagementsListRequest {
	r.product = &product
	return r
}

// Multiple values may be separated by commas.
func (r ApiEngagementsListRequest) ProductProdType(productProdType []int32) ApiEngagementsListRequest {
	r.productProdType = &productProdType
	return r
}

// Comma separated list of exact tags present on product
func (r ApiEngagementsListRequest) ProductTags(productTags []string) ApiEngagementsListRequest {
	r.productTags = &productTags
	return r
}

func (r ApiEngagementsListRequest) ReportType(reportType int32) ApiEngagementsListRequest {
	r.reportType = &reportType
	return r
}

func (r ApiEngagementsListRequest) Requester(requester int32) ApiEngagementsListRequest {
	r.requester = &requester
	return r
}

// * &#x60;Not Started&#x60; - Not Started * &#x60;Blocked&#x60; - Blocked * &#x60;Cancelled&#x60; - Cancelled * &#x60;Completed&#x60; - Completed * &#x60;In Progress&#x60; - In Progress * &#x60;On Hold&#x60; - On Hold * &#x60;Waiting for Resource&#x60; - Waiting for Resource
func (r ApiEngagementsListRequest) Status(status string) ApiEngagementsListRequest {
	r.status = &status
	return r
}

// Tag name contains
func (r ApiEngagementsListRequest) Tag(tag string) ApiEngagementsListRequest {
	r.tag = &tag
	return r
}

// Comma separated list of exact tags
func (r ApiEngagementsListRequest) Tags(tags []string) ApiEngagementsListRequest {
	r.tags = &tags
	return r
}

func (r ApiEngagementsListRequest) TargetEnd(targetEnd string) ApiEngagementsListRequest {
	r.targetEnd = &targetEnd
	return r
}

func (r ApiEngagementsListRequest) TargetStart(targetStart string) ApiEngagementsListRequest {
	r.targetStart = &targetStart
	return r
}

func (r ApiEngagementsListRequest) ThreatModel(threatModel bool) ApiEngagementsListRequest {
	r.threatModel = &threatModel
	return r
}

func (r ApiEngagementsListRequest) Updated(updated time.Time) ApiEngagementsListRequest {
	r.updated = &updated
	return r
}

func (r ApiEngagementsListRequest) Version(version string) ApiEngagementsListRequest {
	r.version = &version
	return r
}

func (r ApiEngagementsListRequest) Execute() (*PaginatedEngagementList, *http.Response, error) {
	return r.ApiService.EngagementsListExecute(r)
}

/*
EngagementsList Method for EngagementsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEngagementsListRequest
*/
func (a *EngagementsAPIService) EngagementsList(ctx context.Context) ApiEngagementsListRequest {
	return ApiEngagementsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedEngagementList
func (a *EngagementsAPIService) EngagementsListExecute(r ApiEngagementsListRequest) (*PaginatedEngagementList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedEngagementList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.apiTest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api_test", r.apiTest, "")
	}
	if r.hasTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_tags", r.hasTags, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.notProductTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_product__tags", r.notProductTags, "csv")
	}
	if r.notTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_tag", r.notTag, "")
	}
	if r.notTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "not_tags", r.notTags, "csv")
	}
	if r.o != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "o", r.o, "csv")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.penTest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pen_test", r.penTest, "")
	}
	if r.product != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product", r.product, "")
	}
	if r.productProdType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product__prod_type", r.productProdType, "csv")
	}
	if r.productTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product__tags", r.productTags, "csv")
	}
	if r.reportType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "report_type", r.reportType, "")
	}
	if r.requester != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requester", r.requester, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "csv")
	}
	if r.targetEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_end", r.targetEnd, "")
	}
	if r.targetStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_start", r.targetStart, "")
	}
	if r.threatModel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threat_model", r.threatModel, "")
	}
	if r.updated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated", r.updated, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngagementsNotesCreateRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
	addNewNoteOptionRequest *AddNewNoteOptionRequest
}

func (r ApiEngagementsNotesCreateRequest) AddNewNoteOptionRequest(addNewNoteOptionRequest AddNewNoteOptionRequest) ApiEngagementsNotesCreateRequest {
	r.addNewNoteOptionRequest = &addNewNoteOptionRequest
	return r
}

func (r ApiEngagementsNotesCreateRequest) Execute() (*Note, *http.Response, error) {
	return r.ApiService.EngagementsNotesCreateExecute(r)
}

/*
EngagementsNotesCreate Method for EngagementsNotesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsNotesCreateRequest
*/
func (a *EngagementsAPIService) EngagementsNotesCreate(ctx context.Context, id int32) ApiEngagementsNotesCreateRequest {
	return ApiEngagementsNotesCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Note
func (a *EngagementsAPIService) EngagementsNotesCreateExecute(r ApiEngagementsNotesCreateRequest) (*Note, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Note
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsNotesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addNewNoteOptionRequest == nil {
		return localVarReturnValue, nil, reportError("addNewNoteOptionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addNewNoteOptionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngagementsNotesRetrieveRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
}

func (r ApiEngagementsNotesRetrieveRequest) Execute() (*EngagementToNotes, *http.Response, error) {
	return r.ApiService.EngagementsNotesRetrieveExecute(r)
}

/*
EngagementsNotesRetrieve Method for EngagementsNotesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsNotesRetrieveRequest
*/
func (a *EngagementsAPIService) EngagementsNotesRetrieve(ctx context.Context, id int32) ApiEngagementsNotesRetrieveRequest {
	return ApiEngagementsNotesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return EngagementToNotes
func (a *EngagementsAPIService) EngagementsNotesRetrieveExecute(r ApiEngagementsNotesRetrieveRequest) (*EngagementToNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EngagementToNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsNotesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/notes/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngagementsPartialUpdateRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
	patchedEngagementRequest *PatchedEngagementRequest
}

func (r ApiEngagementsPartialUpdateRequest) PatchedEngagementRequest(patchedEngagementRequest PatchedEngagementRequest) ApiEngagementsPartialUpdateRequest {
	r.patchedEngagementRequest = &patchedEngagementRequest
	return r
}

func (r ApiEngagementsPartialUpdateRequest) Execute() (*Engagement, *http.Response, error) {
	return r.ApiService.EngagementsPartialUpdateExecute(r)
}

/*
EngagementsPartialUpdate Method for EngagementsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsPartialUpdateRequest
*/
func (a *EngagementsAPIService) EngagementsPartialUpdate(ctx context.Context, id int32) ApiEngagementsPartialUpdateRequest {
	return ApiEngagementsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Engagement
func (a *EngagementsAPIService) EngagementsPartialUpdateExecute(r ApiEngagementsPartialUpdateRequest) (*Engagement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Engagement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedEngagementRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngagementsReopenCreateRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
}

func (r ApiEngagementsReopenCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EngagementsReopenCreateExecute(r)
}

/*
EngagementsReopenCreate Method for EngagementsReopenCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsReopenCreateRequest
*/
func (a *EngagementsAPIService) EngagementsReopenCreate(ctx context.Context, id int32) ApiEngagementsReopenCreateRequest {
	return ApiEngagementsReopenCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EngagementsAPIService) EngagementsReopenCreateExecute(r ApiEngagementsReopenCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsReopenCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/reopen/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEngagementsRetrieveRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
}

func (r ApiEngagementsRetrieveRequest) Execute() (*Engagement, *http.Response, error) {
	return r.ApiService.EngagementsRetrieveExecute(r)
}

/*
EngagementsRetrieve Method for EngagementsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsRetrieveRequest
*/
func (a *EngagementsAPIService) EngagementsRetrieve(ctx context.Context, id int32) ApiEngagementsRetrieveRequest {
	return ApiEngagementsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Engagement
func (a *EngagementsAPIService) EngagementsRetrieveExecute(r ApiEngagementsRetrieveRequest) (*Engagement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Engagement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEngagementsUpdateRequest struct {
	ctx context.Context
	ApiService EngagementsAPI
	id int32
	engagementRequest *EngagementRequest
}

func (r ApiEngagementsUpdateRequest) EngagementRequest(engagementRequest EngagementRequest) ApiEngagementsUpdateRequest {
	r.engagementRequest = &engagementRequest
	return r
}

func (r ApiEngagementsUpdateRequest) Execute() (*Engagement, *http.Response, error) {
	return r.ApiService.EngagementsUpdateExecute(r)
}

/*
EngagementsUpdate Method for EngagementsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this engagement.
 @return ApiEngagementsUpdateRequest
*/
func (a *EngagementsAPIService) EngagementsUpdate(ctx context.Context, id int32) ApiEngagementsUpdateRequest {
	return ApiEngagementsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Engagement
func (a *EngagementsAPIService) EngagementsUpdateExecute(r ApiEngagementsUpdateRequest) (*Engagement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Engagement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EngagementsAPIService.EngagementsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/engagements/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.engagementRequest == nil {
		return localVarReturnValue, nil, reportError("engagementRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.engagementRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
